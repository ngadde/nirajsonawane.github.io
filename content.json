{"meta":{"title":"Niraj Sonawane","subtitle":null,"description":null,"author":"Niraj Sonawane","url":"https://nirajsonawane.github.io"},"pages":[{"title":"About Me","date":"2018-05-19T07:47:06.000Z","updated":"2018-05-19T07:47:06.355Z","comments":true,"path":"About-Me/index.html","permalink":"https://nirajsonawane.github.io/About-Me/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-06-09T17:17:31.485Z","updated":"2018-06-09T13:15:42.578Z","comments":true,"path":"categories/index.html","permalink":"https://nirajsonawane.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-09T17:17:31.344Z","updated":"2018-06-09T13:15:42.579Z","comments":true,"path":"tags/index.html","permalink":"https://nirajsonawane.github.io/tags/index.html","excerpt":"","text":""},{"title":"About Me","date":"2018-05-19T07:47:06.000Z","updated":"2018-05-19T07:47:06.355Z","comments":true,"path":"about/index.html","permalink":"https://nirajsonawane.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Join Method","slug":"Join-Method","date":"2018-06-10T11:40:23.000Z","updated":"2018-06-10T12:11:51.659Z","comments":true,"path":"2018/06/10/Join-Method/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Join-Method/","excerpt":"","text":"This is Second Article in Series of Articles on Java 8 Concurrency Tutorial. The join method allows one thread to wait for the completion of another. If t is a Thread object whose thread is currently executing, t.join();causes the current thread to pause execution until t’s thread terminates. Overloads of join allow the programmer to specify a waiting period. However, as with sleep, join is dependent on the OS for timing, so you should not assume that join will wait exactly as long as you specify. join responds to an interrupt by exiting with an InterruptedException Join Method Example1234567891011121314public class JoinMethodExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1 = new Thread(()-&gt;System.out.println(\"Thread Number 1\")); Thread t2 = new Thread(()-&gt;System.out.println(\"Thread Number 2\")); t1.start(); t2.start(); System.out.println(\"Main Method End\"); &#125;&#125; If you check output , The main Thread ends before T2 Thread. If you want to wait for Completion of T2 then we need to call join method. Join Method Example12345678910111213141516public class JoinMethodExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1 = new Thread(()-&gt;System.out.println(\"Thread Number 1\")); Thread t2 = new Thread(()-&gt;System.out.println(\"Thread Number 2\")); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Main Method End\"); &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Creating Threads in Java","slug":"Creating-Threads","date":"2018-06-10T10:17:39.000Z","updated":"2018-06-10T12:09:20.180Z","comments":true,"path":"2018/06/10/Creating-Threads/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Creating-Threads/","excerpt":"","text":"This is First Article in Series of Articles on Java 8 Concurrency Tutorial. Threads can be Created using below ways.Extending Thread classThe First way is to extend the Thread class, and override the run()The extending class must override run() method which is the entry point of new thread. Extending Thread class1234567891011121314151617181920212223242526class ThreadRunner extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner : \" + i); &#125; &#125; &#125;public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1= new ThreadRunner(); t1.start(); System.out.println(\"Main Method End\"); &#125;&#125; Implementing the Runnable InterfaceWe Can pass an implementation of the Runnable interface to the constructor of Thread, then call start() Implementing the Runnable Interface12345678910111213141516171819202122232425class ThreadRunner implements Runnable&#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner1 : \" + i); &#125; &#125; &#125;public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1= new Thread(new ThreadRunner()); t1.start(); System.out.println(\"Main Method End\"); &#125;&#125; Threads Using Anonymous ClassesAnonymous Inner class is an inner class that is declared without any class name and that’s why it’s called anonymous. You can define an anonymous inner class within a method or even within an argument to a method. Anonymous class can be used to -Extend an class and override its method.Implement an interface and provide an implementation of its method. Threads Using Anonymous Classes1234567891011121314151617public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner : \" + i); &#125; &#125; &#125;).start(); &#125;&#125; Threads Using Java 8 LambdaRunnable is a functional interface and we can use lambda expressions to provide it’s implementation rather than using anonymous class. Threads Using Anonymous Classes12345678910public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; Runnable task = () -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner2 : \" + i); &#125; &#125;; new Thread(task).start(); &#125;&#125; Next Join Method. in Series of Articles on Java 8 Concurrency Tutorial.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Java 8 Concurrency Tutorial","slug":"Concurrency-1-0","date":"2018-06-10T09:56:34.000Z","updated":"2018-06-10T12:10:10.870Z","comments":true,"path":"2018/06/10/Concurrency-1-0/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Concurrency-1-0/","excerpt":"","text":"Welcome to Java Concurrency tutorials. These articles will describe you the Java Concurrency concepts in the context of Java 8 with easily understood code examples. The majority of concepts shown in these articles are also available in older versions of Java.However, my code samples focus on Java 8 and make heavy use of lambda expressions and other new features. Topics Creating Threads in Java Join Method Threads pools with the Executor Framework Futures and Callables CompletableFuture Nonblocking algorithms Fork-Join in Java 7 Deadlock Check The First Article in Series of Java Concurrency tutorials Creating Threads in Java.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Watching a Directory for Changes","slug":"Watching-a-Directory-for-Changes","date":"2018-06-01T01:12:32.000Z","updated":"2018-06-09T19:05:32.934Z","comments":true,"path":"2018/06/01/Watching-a-Directory-for-Changes/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/01/Watching-a-Directory-for-Changes/","excerpt":"","text":"The java.nio.file package provides a file change notification API, called the Watch Service API. This API enables you to register a directory (or directories) with the watch service. When registering, you tell the service which types of events you are interested in:1:File creation.2:File deletion.3:File Modification. When the service detects an event of interest, it is forwarded to the registered process. The registered process has a thread (or a pool of threads) dedicated to watching for any events it has registered for. When an event comes in, it is handled as needed. Creating watcher serviceThe first step is to create a new WatchService by using the newWatchService method in the FileSystem class, as follows: WatchService watcher = FileSystems.getDefault().newWatchService() Registering for EventsWe Can register one or more objects with the watch service.Any object that implements the Watchable interface can be registered.The Path class implements the Watchable interface, so each directory to be monitored is registered as a Path object. When registering an object with the watch service, you specify the types of events that you want to monitor. The supported StandardWatchEventKinds event types follow: ENTRY_CREATE – A directory entry is created. ENTRY_DELETE – A directory entry is deleted. ENTRY_MODIFY – A directory entry is modified. Registering for Events123WatchService watcher = FileSystems.getDefault().newWatchService()Path dir = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\\");dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY); Directory Watching ExamplePutting all above together. We can now go ahead and look at a complete and practical example. In below example we are going to watch directory for all the changes and will process the events. Directory Watching Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;import java.io.IOException;import java.nio.file.FileSystems;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.WatchEvent;import java.nio.file.WatchKey;import java.nio.file.WatchService; public class DirectoryChangeListeners &#123; public static void main(String[] args) throws InterruptedException &#123; try &#123; WatchService watcher = FileSystems.getDefault().newWatchService(); Path dir = Paths.get(\"C:\\\\data\\\\temp\\\\\"); dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY); System.out.println(\"Watch Service registered for dir: \" + dir.getFileName()); WatchKey key; while ((key = watcher.take())!=null) &#123; for (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123; WatchEvent.Kind&lt;?&gt; kind = event.kind(); @SuppressWarnings(\"unchecked\") WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;) event; Path fileName = ev.context(); if(kind==ENTRY_CREATE) &#123; System.out.println(\"New File Added, file Name \" + fileName); &#125; if(kind==ENTRY_DELETE) &#123; System.out.println(\"File Deleted \" + fileName); &#125; if (kind == ENTRY_MODIFY ) &#123; System.out.println(\"File Modified \" + fileName); &#125; &#125; boolean valid = key.reset(); if (!valid) &#123; break; &#125; &#125; &#125; catch (IOException ex) &#123; System.err.println(ex); &#125; &#125;&#125; Key PointsThree methods are available for Retrieving events : poll – Returns a queued key, if available. Returns immediately with a null value, if unavailable. poll(long, TimeUnit) – Returns a queued key, if one is available. If a queued key is not immediately available, the program waits until the specified time. The TimeUnit argument determines whether the specified time is nanoseconds, milliseconds, or some other unit of time. take – Returns a queued key. If no queued key is available, this method waits. Reset keyAfter the events for the key have been processed, you need to put the key back into a ready state by invoking reset. If this method returns false, the key is no longer valid and the loop can exit. This step is very important. If you fail to invoke reset, this key will not receive any further events. When to Use and Not Use This APIThe Watch Service API is designed for applications that need to be notified about file change events. It is well suited for any application, like an editor or IDE, that potentially has many open files and needs to ensure that the files are synchronized with the file system. It is also well suited for an application server that watches a directory, perhaps waiting for .jsp or .jar files to drop, in order to deploy them. This API is not designed for indexing a hard drive. Most file system implementations have native support for file change notification. The Watch Service API takes advantage of this support where available. However, when a file system does not support this mechanism, the Watch Service will poll the file system, waiting for events.","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 File Operations - Copy,Delete,Move","slug":"java-8-File-Operations-Copy-Delete-Move","date":"2018-05-30T01:22:00.000Z","updated":"2018-06-09T19:07:07.541Z","comments":true,"path":"2018/05/30/java-8-File-Operations-Copy-Delete-Move/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/30/java-8-File-Operations-Copy-Delete-Move/","excerpt":"","text":"Deleting a File or DirectoryThe Files class provides two deletion methods. 1 : The delete(Path) method deletes the file or throws an exception if the deletion fails 2 : The deleteIfExists(Path) method also deletes the file, but if the file does not exist, no exception is thrown. Delete File12345678910111213public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); try &#123; Files.delete(path); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Delete Empty Directory12345678910111213public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\\"); try &#123; Files.delete(path); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Trying to delete Non Empty Directory will throw DirectoryNotEmptyException.So, First we need to delete all files inside a particular non-empty directory: Delete Non Empty Directory1234567891011public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\\"); Files.walk(path) .sorted(Comparator.reverseOrder()) .map(Path::toFile) .forEach(File::delete); &#125; Copying a File or DirectoryYou can copy a file or directory by using thecopy(Path, Path, CopyOption...) method. The copy fails if the target file exists, unless the REPLACE_EXISTING option is specified. This method takes a varargs argument. The following StandardCopyOption and LinkOption enums are supported: REPLACE_EXISTING – replace a file if it existsCOPY_ATTRIBUTES – copy metadata to the new fileNOFOLLOW_LINKS – shouldn’t follow symbolic links Copy File12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destination.txt\"); Files.copy(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Copy Empty Directory12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destinationDir\"); Files.copy(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Copy Non empty DirectoryDirectories can be copied. However, files inside the directory are not copied, so the new directory is empty even when the original directory contains files. Copy Non Empty Directory recursively12345678910111213141516public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destinationDir\"); Files.walk(sourcepath) .forEach(source -&gt; copy(source, destinationepath.resolve(sourcepath.relativize(source)))); &#125; static void copy(Path source, Path dest) &#123; try &#123; Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; &#125; Moving a File or DirectoryYou can move a file or directory by using the move(Path, Path, CopyOption...) method.The move fails if the target file exists, unless the REPLACE_EXISTING option is specified. Empty directories can be moved. If the directory is not empty, the move is allowed when the directory can be moved without moving the contents of that directory. On UNIX systems, moving a directory within the same partition generally consists of renaming the directory. In that situation, this method works even when the directory contains files. This method takes a varargs argument – the following StandardCopyOption enums are supported: REPLACE_EXISTING – Performs the move even when the target file already exists. If the target is a symbolic link, the symbolic link is replaced but what it points to is not affected.ATOMIC_MOVE – Performs the move as an atomic file operation. If the file system does not support an atomic move, an exception is thrown. With an ATOMIC_MOVE you can move a file into a directory and be guaranteed that any process watching the directory accesses a complete file. Move File12345678public static void main(String[] args) &#123; Path sourcepath = Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\temp.txtr\");Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Move Empty Directory12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\copyme\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\copyme\"); Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Move Non Empty Directory1234567public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\copyme\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\copyme\"); Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 List all Files in Directory and Subdirectories","slug":"Java-8-List-all-Files-in-Directory-and-Subdirectories","date":"2018-05-29T02:10:02.000Z","updated":"2018-06-09T19:07:28.343Z","comments":true,"path":"2018/05/29/Java-8-List-all-Files-in-Directory-and-Subdirectories/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/29/Java-8-List-all-Files-in-Directory-and-Subdirectories/","excerpt":"","text":"List All Files in Directory and SubdirectoriesFiles.walk Return a Stream that is lazily populated with Path by walking the file tree rooted at a given starting file. Files.list Method Return a lazily populated Stream for the current directory only,Files.walk can be used to get list of files from Directory &amp; Subdirectories . Example 1: List All Files in Directory and SubdirectoriesList All Files in Directory and Subdirectories123456789101112131415public static void main(String[] args) throws IOException &#123; Path start = Paths.get(\"C:\\\\data\\\\\"); try (Stream&lt;Path&gt; stream = Files.walk(start, Integer.MAX_VALUE)) &#123; List&lt;String&gt; collect = stream .map(String::valueOf) .sorted() .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; &#125; NoteFiles.walk method takes int maxDepth as parameter. The maxDepth parameter is the maximum number of levels of directories to visit.MAX_VALUE may be used to indicate that all levels should be visited. Value 1 can be used to list files in current Directory. Example 2: List All Files in Current Directory onlyList All Files in Current Directory only12345678910111213141516public static void main(String[] args) throws IOException &#123; Path start = Paths.get(\"C:\\\\data\\\\\"); try (Stream&lt;Path&gt; stream = Files.walk(start, 1)) &#123; List&lt;String&gt; collect = stream .map(String::valueOf) .sorted() .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File With try-with-resources","slug":"Java-8-Read-File-With-try-with-resources","date":"2018-05-24T01:58:00.000Z","updated":"2018-05-23T17:16:29.444Z","comments":true,"path":"2018/05/24/Java-8-Read-File-With-try-with-resources/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/24/Java-8-Read-File-With-try-with-resources/","excerpt":"","text":"You might have noticed that In the previous post about files we have not closed any file stream. Streams implement AutoCloseable and in this case, we need to close stream explicitly. We can use try-with-resources to close the stream. Sample CodeClose BufferedReader123456789101112public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; try(BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) &#123; reader.lines().forEach(System.out::println); &#125; catch (Exception e) &#123; // TODO: handle exception &#125;&#125; Close Stream1234567891011public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; try(Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath)))) &#123; lines.forEach(System.out::println); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"5.0 -Read File With try-with-resources","slug":"Java-8/File/5-0-Read-File-With-try-with-resources","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/5-0-Read-File-With-try-with-resources/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 List All Files in Directory","slug":"java-8-List-All-Files-in-Directory","date":"2018-05-23T17:32:00.000Z","updated":"2018-05-23T18:48:21.282Z","comments":true,"path":"2018/05/23/java-8-List-All-Files-in-Directory/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/23/java-8-List-All-Files-in-Directory/","excerpt":"","text":"List All Files in DirectoryFiles.list Method Return a lazily populated Stream, the elements of which are the entries in the directory. We Can use the stream operations to find Specific Files, List file matching certain criteria, List filenames in sorted order etc. Example 1: List All Files in DirectoryList All Files in Directory12345678public static void main(String[] args) throws IOException &#123; try(Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"));) &#123; list.forEach(System.out::println); &#125; &#125; Example 2: List All Files in Directory Starting with AList All Files in Directory Starting with A1234567891011121314public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.map(path -&gt; path.getFileName() .toString()) .filter(name -&gt; name.startsWith(\"A\")) .sorted() .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 3: List Files OnlyList Files Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isFile()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 4: List Directory OnlyList Directory Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isDirectory()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 5: List Hidden files OnlyList Hidden files Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isHidden()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; NoteFiles.list Method Return a lazily populated Stream for the directory.It does not return Stream for the nested directory. For that, we Can use File.walk . Will discuss that in next chapter.","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"6.0 - List All Files in Directory","slug":"Java-8/File/6-0-List-All-Files-in-Directory","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/6-0-List-All-Files-in-Directory/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File Using Buffered Reader","slug":"Java-8-Read-File-Using-Buffered-Reader","date":"2018-05-23T01:58:08.000Z","updated":"2018-05-23T17:22:35.928Z","comments":true,"path":"2018/05/23/Java-8-Read-File-Using-Buffered-Reader/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/23/Java-8-Read-File-Using-Buffered-Reader/","excerpt":"","text":"Finally, Java 8 has made Reading &amp; Writing a text file a simple task. If we need more fine-grained control on reading we can use new Files.newBufferedReader() Read File Using Buffered Reader12345678910111213141516import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadUsingBufferedReader &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; BufferedReader reader = Files.newBufferedReader(Paths.get(filePath)); reader.lines().forEach(System.out::println); &#125; &#125; Sample.txt file1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"4.0 -Read File Using Buffered Reader","slug":"Java-8/File/4-0-Read-File-Using-Buffered-Reader","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/4-0-Read-File-Using-Buffered-Reader/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File As Single String","slug":"Java-8-Read-File-As-Single-String","date":"2018-05-22T01:58:08.000Z","updated":"2018-05-23T16:32:30.845Z","comments":true,"path":"2018/05/22/Java-8-Read-File-As-Single-String/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/22/Java-8-Read-File-As-Single-String/","excerpt":"","text":"Java 8 has added Files.lines() method, which can be used to read the file as Stream. Joining Collector Can be used to convert Stream to Single String. Read file as a stream12345678910111213141516import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadFileAsString &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath))); String fileAsString = lines.collect(Collectors.joining()); System.out.println(fileAsString); &#125; &#125; Sample.txt file for testing.1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"3.0 -Read File As Single String","slug":"Java-8/File/3-0-Read-File-As-Single-String","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/3-0-Read-File-As-Single-String/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File As A Stream","slug":"Java-8-Read-File-As-A-Stream","date":"2018-05-21T01:58:08.000Z","updated":"2018-05-23T16:33:28.212Z","comments":true,"path":"2018/05/21/Java-8-Read-File-As-A-Stream/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/21/Java-8-Read-File-As-A-Stream/","excerpt":"","text":"Java 8 has added Files.lines() method, which can be used to read the file as Stream. Read file as a stream1234567891011121314151617import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadFileAsStream &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath))); lines.forEach(System.out::println); &#125; &#125; sample.txt for testing.1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7 Output:","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"2.0 -Read File As A Stream","slug":"Java-8/File/2-0-Read-File-As-A-Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/2-0-Read-File-As-A-Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File Line By Line","slug":"Java-8-Read-File-Line-By-Line","date":"2018-05-20T01:58:08.000Z","updated":"2018-05-23T16:11:15.011Z","comments":true,"path":"2018/05/20/Java-8-Read-File-Line-By-Line/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/20/Java-8-Read-File-Line-By-Line/","excerpt":"","text":"Java 8 has addded Files.readAllLines() method ,which can be used to read file as List of Strings. Read file as a List of Strings1234567891011public class Java8ReadFileAsListOfStrings &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; List&lt;String&gt; readAllLines = Files.readAllLines(Paths.get((filePath))); readAllLines.forEach(System.out::println); &#125; &#125; Text file sample.txt for testing. 1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7 Output:","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"1.0 -Read File Line by Line","slug":"Java-8/File/1-0-Read-File-Line-by-Line","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/1-0-Read-File-Line-by-Line/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java Process Builder","slug":"Java-Process-Builder","date":"2018-05-19T18:35:48.000Z","updated":"2018-05-23T17:20:58.527Z","comments":true,"path":"2018/05/20/Java-Process-Builder/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/20/Java-Process-Builder/","excerpt":"","text":"The ProcessBuilder class is used to create separate operating system processes. There are many scenarios, Where we need to launch separate operating system processes form java program. Before JDK 5.0, We need to use the exec() method of the java.lang.Runtime class to start new process. JDK 5.0 has added ProcessBuilder to Start new OS process. Note:ProcessBuilder is not synchronized. If multiple threads access a ProcessBuilder instance concurrently, and at least one of the threads modifies one of the attributes structurally, it must be synchronized externally. Starting a new process which uses the default working directory and the environment is easy: 123Process p = new ProcessBuilder(\"myCommand\", \"myArg\").start(); The ProcessBuilder class defines two constructors, such as:12345ProcessBuilder(List&lt;String&gt; command);//Constructs a process builder with the specified operating system program and arguments.ProcessBuilder(String... command);//Constructs a process builder with the specified operating system program and arguments ProcessBuilder Examples.1:Run External bat file/sh file.In this example, We will try to run demo.bat file. The demo.bat file is at src/ root location.The out put of process builder will be printed on consol. 1234567891011121314151617181920212223242526272829303132333435public class ProcessBuilderExample &#123; public static void main(String[] args) &#123; try &#123; System.out.println(\"ProcessBuilderExample.Start!!\"); final File batchFile = new File(\"src\\\\demo.bat\"); ProcessBuilder processBuilder = new ProcessBuilder(batchFile.getAbsolutePath()); Process process = processBuilder.start(); int resposneCode = process.waitFor(); if (resposneCode == 0) &#123; System.out.println(\"Process executed successfully\"); InputStream inputStream = process.getInputStream(); String result = readInputStreamData(inputStream); System.out.println(result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static String readInputStreamData(InputStream input) throws IOException &#123; try (BufferedReader buffer = new BufferedReader(new InputStreamReader(input))) &#123; return buffer.lines() .collect(Collectors.joining(\"\\n\")); &#125; &#125;&#125; demo.bat File1echo &quot;Hello World&quot;","categories":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/categories/Java/"},{"name":"Java Process Builder","slug":"Java/Java-Process-Builder","permalink":"https://nirajsonawane.github.io/categories/Java/Java-Process-Builder/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-9","slug":"Java-9","permalink":"https://nirajsonawane.github.io/tags/Java-9/"}]}]}