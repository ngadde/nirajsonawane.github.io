{"meta":{"title":"Niraj Sonawane","subtitle":null,"description":null,"author":"Niraj Sonawane","url":"https://nirajsonawane.github.io"},"pages":[{"title":"About Me","date":"2018-05-19T07:47:06.000Z","updated":"2018-05-19T21:17:08.000Z","comments":true,"path":"About-Me/index.html","permalink":"https://nirajsonawane.github.io/About-Me/index.html","excerpt":"","text":""},{"title":"About Me","date":"2018-05-19T07:47:06.000Z","updated":"2019-01-22T04:49:48.323Z","comments":true,"path":"about/index.html","permalink":"https://nirajsonawane.github.io/about/index.html","excerpt":"","text":"I am Software Developer from India. My Passion is to Write Clean,Elegant and Scalable Code. I love to follow latest trends and Best Practices in software engineering.I am a strong believer that success lies in balancing the fine line between YAGNI and “do it right the first time” coding philosophies. Creating a good software is not a one time activity but it’s continually evolving process. Find it Interesting? Check out my Portfolio This blog is my Attempt to share my learning to best of my Capabilities :) Let’s make something awesome together Contact me on niraj.sonawane@gmail.com"},{"title":"Categories","date":"2018-11-29T19:59:17.887Z","updated":"2018-06-10T02:45:44.000Z","comments":true,"path":"categories/index.html","permalink":"https://nirajsonawane.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-29T19:59:17.903Z","updated":"2018-06-10T02:45:44.000Z","comments":true,"path":"tags/index.html","permalink":"https://nirajsonawane.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Write Clean Asynchronous Code With CompletableFuture Java-8","slug":"Write-Clean-asynchronous-code-with-CompletableFuture-Java-8","date":"2019-01-27T16:43:44.000Z","updated":"2019-02-02T11:28:50.893Z","comments":true,"path":"2019/01/27/Write-Clean-asynchronous-code-with-CompletableFuture-Java-8/","link":"","permalink":"https://nirajsonawane.github.io/2019/01/27/Write-Clean-asynchronous-code-with-CompletableFuture-Java-8/","excerpt":"","text":"unsplash-logorawpixel Java 8 has introduced a lot of features. With Addition of CompletableFuture . Writing Clean &amp; Readable Asynchronous code has become much more easier. CompletableFuture has more than 50 methods which makes it very useful.The code for this post is available for download here. CompletableFutureCompletableFuture is an implementation of the Future &amp; CompletionStage interface but with a lot of modern Features. It Supports lambdas and takes advantage of non-blocking methods via callbacks and promotes asynchronous reactive programming model. CompletableFuture allows us to write non-blocking code by running a task on a separate thread than the main application thread and notifying the main thread about its Progress, Completion or Failure. CompletableFuture is inspired from ListenableFuture in Guava and Are similar to Promise in java scripts. Why CompletableFuture instead Of Future?Callable and Future were introduced in Java 5. Future is placeholders for a result that hasn’t happened yet.Future Can use a Runnable or Callable instance to complete the submitted task. There are two methods to get actual value from Future.get() : When this method is called, thread will wait for result indefinitely.get(long timeout, TimeUnit unit): When this method is called, thread will wait for result only for specified time.There are multiple problems with FutureBlocking - The get method is blocking and need to wait until the computation is done. Future does not have any method that can notify on completion and does not have capability to attach a callback function.Chaining &amp; Composition - Many times we want to chain multiple future to complete long computation. You need to merger results and send results to another task. It’s Hard to implement such chaining with future.Exception Handling - Future does not provide any construct for Exception Handling.All these issues are addressed by CompletableFuture.lets try different methods provided by CompletableFutureCreate Simple Completeable FutureThe simplest way is to create CompleteableFuture is CompleteableFuture.completedFuture method which returns an a new, finished CompleteableFuture. Creating already Completed CompleteableFuture becomes very useful in many cases.Create Completed CompleteableFuture12345678910@Testvoid simpleComletedCompletableFuture() &#123;CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.completedFuture(\"Some Value\"); assertTrue(completableFuture.isDone()); try &#123; assertEquals(\"Some Value\", completableFuture.get()); &#125; catch (ExecutionException | InterruptedException e) &#123; fail(\"No Exception expected\");&#125;&#125; Note : if we call get method on incomplete CompleteableFuture , the get call will block forever because the Future is never completed.We can use CompletableFuture.complete() method to manually complete a Future. Simple Asynchronous computation using runAsyncIf We want to run some task in background that does not returns any value, then we can use CompletableFuture.runAsync() it takes a Runnable and returns CompletableFuture&lt;Void&gt;Simple Asynchronous computation using runAsync1234567891011 public void process() &#123; System.out.println(Thread.currentThread() + \" Process\"); someStateVaribale.set(100);&#125;@Testvoid completableFutureRunAsync() &#123; CompletableFuture&lt;Void&gt; runAsync = CompletableFuture.runAsync(() -&gt; process()); runAsync.join(); assertEquals(100, someStateVaribale.get());&#125; Simple Asynchronous computation using SupplyAsyncIf we want to run some task in background that Returns Some Value, then we can use CompletableFuture.supplyAsync() it takes a Supplier&lt;T&gt; and returns completableFuture&lt;T&gt;Simple Asynchronous computation using supplyAsync123456789@Testvoid completableFutureSupplyAsync() &#123; CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(this::processSomeData); try &#123; assertEquals(\"Some Value\", supplyAsync.get()); //Blocking &#125; catch (ExecutionException | InterruptedException e) &#123; fail(\"No Exception expected\"); &#125;&#125; CompletableFuture with Custom ExecutorYou might be wondering, Which Thread is executing the supplyAsync &amp; runAsync task and Who is creating these Threads? Similar to parallel streams CompletableFuture executes these tasks in a thread obtained from the global ForkJoinPool.commonPool().We Can always provide our custom Executor to CompletableFuture.All the methods in the CompletableFuture API has two variants, With or Without Executor.CompletableFuture with Custom Executor12345678910 @Testvoid completableFutureSupplyAsyncWithExecuto() &#123; ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(2); CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(this::processSomeData,newFixedThreadPool); try &#123; assertEquals(\"Some Value\", supplyAsync.get()); &#125; catch (ExecutionException | InterruptedException e) &#123; fail(\"No Exception expected\"); &#125;&#125; CompletableFuture Callbacks and ChainingWe know that CompletableFuture.get() is blocking and we want to avoid this. We should get some notification after Future completes.CompletableFuture provides thenApply(), thenAccept() and thenRun() to attach callbacks thenAccept()If We want to run some code after receiving some value from Future then we can use thenAccept()thenApply()If We want to run some code after receiving value from Future and then want to return some value for this we can use thenAccept()thenRun()If We want to run some code after completion of the Future and dont want to return any value for this we can use thenRun() CompletableFuture thenAccept thenApply thenRun123456789101112131415161718192021222324 @Testpublic void completableFutureThenAccept() &#123; CompletableFuture.supplyAsync(this::process) .thenAccept(this::notify) //Non Blocking,notify method will be called automatically after compilation or process method .join(); assertEquals(100,someStateVaribale.get()); &#125;@Testpublic void completableFutureThenApply() &#123; Integer notificationId = CompletableFuture.supplyAsync(this::process) .thenApply(this::notify)//Non Blocking will return some value .join(); assertEquals(new Integer(1),notificationId); &#125; @Test public void completableFutureThenApply() &#123; CompletableFuture.supplyAsync(this::process) .thenRun(this::notifyMe) .join(); assertEquals(100,someStateVaribale.get()); &#125; Chaining CallbacksIf We have large Asynchronous computation, Then we can continue passing values from one callback to another.Chaining Callbacks12345678 @Testpublic void completableFutureThenApplyAccept() &#123; CompletableFuture.supplyAsync(this::findAccountNumber) .thenApply(this::calculateBalance) .thenApply(this::notifyBalance) .thenAccept((i)-&gt;notifyByEmail()).join();&#125;async variants of thenApply(),thenAccept() and thenRun()Note In all the previus examples, All methods are executed on Same threads. But If we want them to be run on separate thread then we can use async variants of these methods.Async Variants12345678910111213 @Testpublic void completableFutureApplyAsync() &#123; ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(2); ScheduledExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor(); CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture .supplyAsync(this::findAccountNumber,newFixedThreadPool)//will run on thread obtain from newFixedThreadPool .thenApplyAsync(this::calculateBalance,newSingleThreadScheduledExecutor) //will run on thread obtain from newSingleThreadScheduledExecutor .thenApplyAsync(this::notifyBalance);//will run on thread obtain from common pool Integer balance = completableFuture.join(); assertEquals(Integer.valueOf(balance), Integer.valueOf(100)); &#125; CompletableFuture thenCompose and thenCombinethenComposeLet’s Say we want to first find Account Number and then calculate Balance for that account and after calculations we want to send notifications.Now All these task are Dependent and methods are returning CompletableFuture , Then We need to use thenCompose Method.This is similar to flatMap in case of Streams.thenCompose123456789101112131415161718192021222324252627282930313233 public CompletableFuture&lt;Integer&gt; findAccountNumber() &#123; sleep(1); System.out.println(Thread.currentThread() + \" findAccountNumber\"); return CompletableFuture.completedFuture(10);&#125;public CompletableFuture&lt;Integer&gt; calculateBalance(int accountNumber) &#123; System.out.println(Thread.currentThread() + \" calculateBalance\"); sleep(1); return CompletableFuture.completedFuture(accountNumber * accountNumber);&#125;public CompletableFuture&lt;Integer&gt; notifyBalance(Integer balance) &#123; System.out.println(Thread.currentThread() + \"Sending Notification\"); sleep(1); return CompletableFuture.completedFuture(balance); &#125;private void sleep(int seconds) &#123; try &#123; TimeUnit.SECONDS.sleep(seconds); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; @Testpublic void completableFutureThenCompose()&#123; Integer join = findAccountNumber() .thenComposeAsync(this::calculateBalance) .thenCompose(this::notifyBalance) .join(); assertEquals(new Integer(100), join);&#125; thenCombineAs name suggest thenCombine is used to merge results of two independent CompletableFuture. Assume that for a person we get first name and last name by calling two different independent methods. To get the Full name we want ot merge results of both the methods then we will use thenCombine.thenCombine123456789101112131415161718192021 public CompletableFuture&lt;String&gt; findFirstName() &#123; return CompletableFuture.supplyAsync(() -&gt; &#123; sleep(1); return \"Niraj\"; &#125;); &#125;public CompletableFuture&lt;String&gt; findLastName() &#123; return CompletableFuture.supplyAsync(() -&gt; &#123; sleep(1); return \"Sonawane\"; &#125;);&#125;@Testpublic void completableFutureThenCombine() &#123; CompletableFuture&lt;String&gt; thenCombine = findFirstName().thenCombine(findLastName(), (firstName, lastname) -&gt; &#123; return firstName + lastname;&#125;); String fullName = thenCombine.join(); assertEquals(\"NirajSonawane\", fullName); &#125; CompletableFuture allOfIn Many scenario we want to run run multiple task in parallel and want to do some processing after all of them are complete. Assume we want to find firstName of five different users and combine the results.The CompletableFuture.allOf static method allows to wait for completion of all of the Futures.The allOf method has limitation that it does not return the combined results of all Futures. We you have to manually combine the results from Futures.allOf123456789101112131415161718192021222324public CompletableFuture&lt;String&gt; findSomeValue() &#123; return CompletableFuture.supplyAsync(() -&gt; &#123; sleep(1); return \"Niraj\"; &#125;);&#125; @Testpublic void completableFutureAllof() &#123; List&lt;CompletableFuture&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); IntStream.range(0, 5).forEach(num -&gt; &#123; list.add(findSomeValue());&#125;);CompletableFuture&lt;Void&gt; allfuture = CompletableFuture.allOf(list.toArray(new CompletableFuture[list.size()]));//Created All of object CompletableFuture&lt;List&lt;String&gt;&gt; allFutureList = allfuture.thenApply(val -&gt; &#123; return list.stream().map(f -&gt; f.join()).collect(Collectors.toList());&#125;); CompletableFuture&lt;String&gt; futureHavingAllValues = allFutureList.thenApply(fn -&gt; &#123; System.out.println(\"I am here\"); return fn.stream().collect(Collectors.joining());&#125;); String concatenateString = futureHavingAllValues.join(); assertEquals(\"NirajNirajNirajNirajNiraj\", concatenateString);&#125; CompletableFuture Exception HandlingHanding Exceptions in Multithreaded code in Java was always pain. Luckily CompletableFuture has a nice way of handling exceptions.Exception Handling1234CompletableFuture&lt;Integer&gt; thenApply = CompletableFuture .supplyAsync(this::findAccountNumber) .thenApply(this::calculateBalance) .thenApply(this::notifyBalance)In Above Code if findAccountNumber method throws the Exception then callback chain calculateBalance and notifyBalance will not be called. Future will be resolved with the exception occurred.Similarly if calculateBalance throws the Exception then after the callback chain will break. Handel Exceptions using exceptionally Exceptionally callback will be called if preceding methods fails with an exception. exceptionally Returns a new CompletableFuture that is completed when this CompletableFuture completes, with the result of the given function of the exception triggering this CompletableFuture’s completion when it completes exceptionally; otherwise, if this CompletableFuture completes normally, then the returned CompletableFuture also completes normally with the same value.exceptionally1234567891011121314 @Test public void completableFutureExceptionally() &#123;CompletableFuture&lt;Integer&gt; thenApply = CompletableFuture.supplyAsync(this::findAccountNumber) .thenApply(this::calculateBalance) .thenApply(this::notifyBalance) .exceptionally(ex -&gt; &#123; System.out.println(\"Got Some Exception \"+ex.getMessage()); System.out.println(\"Returning some default value\"); return 0; &#125;); Integer join = thenApply.join(); assertEquals(new Integer(0), join); &#125; Handel Exceptions using Handel Method Handel method is more flexible than exceptionally method.As we get both exception as well as Result.Handel1234567891011121314151617@Testpublic void completableFutureHandel()&#123;CompletableFuture&lt;Integer&gt; thenApply = CompletableFuture.supplyAsync(this::findAccountNumber) .thenApply(this::calculateBalance) .thenApply(this::notifyBalance) .handle((ok, ex) -&gt; &#123; System.out.println(\"Code That we want to run in finally \"); if (ok != null) &#123; System.out.println(\"No Exception !!\"); &#125; else &#123; System.out.println(\"Got Exception \" + ex.getMessage()); return -1; &#125; return ok; &#125;); &#125; Handel Exceptions using WhenComplete MethodWhenComplete12345678@Testpublic void completableFutureWhenComplete()&#123; CompletableFuture.supplyAsync(this::findAccountNumber) .thenApply(this::calculateBalance) .thenApply(this::notifyBalance) .whenComplete((i,t)-&gt;System.out.println(\"finally action\")); &#125; TimeOut java 9 ImprovementWhile Working on Asynchronous Code, We Need to handel timeouts. We Can not wait forever to finish the task. Unfortunately we do not have anything in java 8 for timeouts.Java 9 has added orTimeout and completeOnTimeout methods to handel this. If the task does not complete in given time, a TimeoutException will be thrown. orTimeout123456@Testpublic void completableFutureWhenComplete()&#123; CompletableFuture.supplyAsync(this::findAccountNumber) .orTimeout(1, TimeUnit.MINUTES); &#125; The code for this post is available for download here.","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"}],"tags":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"},{"name":"Java-9","slug":"Java-9","permalink":"https://nirajsonawane.github.io/tags/Java-9/"}]},{"title":"Document Spring Boot RESTful API With Swagger-2.0","slug":"Document-Spring-Boot-RESTful-API-With-Swagger-2-0","date":"2019-01-20T08:40:46.000Z","updated":"2019-01-21T04:28:44.663Z","comments":true,"path":"2019/01/20/Document-Spring-Boot-RESTful-API-With-Swagger-2-0/","link":"","permalink":"https://nirajsonawane.github.io/2019/01/20/Document-Spring-Boot-RESTful-API-With-Swagger-2-0/","excerpt":"","text":"unsplash-logoPuttipol Waipanya Now Days Spring Boot is de facto standard for developing RESTful services.Spring Boot makes it very easy to build RESTful services.In SOAP based web services, you had a WSDL which works as documentation for your API. For Rest Services we do not have WSDL so documentation of API becomes more critical. SwaggerSwagger 2 is an open source framework used to describe and document RESTful APIs.Swagger Can read your API’s structure and automatically build beautiful and interactive API documentation. Swagger makes documenting your RESTful services easy.Check Docs for all Features. The code for this post is available for download here. Swagger + Spring BootSwagger Can easily integrate with Spring Boot. To Integrate Swagger we need to use Swagger UI &amp; SpringFox. Maven Dependency1234567891011 &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; Demo Spring Boot RESTful Applicationlet’s Create documentation for our Demo Spring Boot RESTful Application. Demo Application expose User rest endpoint that allows to perform CURD operations for User. User Endpoint123456789101112131415161718192021222324 @GetMappingpublic List&lt;User&gt; getAllUsers() &#123; return userservice.getAllUsers();&#125;@GetMapping(\"/&#123;id&#125;\")public User getUser(@PathVariable int id) &#123; return userservice.getUser(id);&#125;@PostMappingpublic ResponseEntity addUser(@RequestBody User user) &#123; userservice.addUser(user); return new ResponseEntity(\"User Added successfully\", HttpStatus.OK);&#125;@PutMappingpublic ResponseEntity updateUser(@RequestBody User user) &#123; userservice.updateUser(user); return new ResponseEntity(\"User Updated successfully\", HttpStatus.OK);&#125;@DeleteMapping(\"/&#123;id&#125;\")public ResponseEntity deleteUser(@PathVariable int id) &#123; userservice.deleteUser(id); return new ResponseEntity(\"User Deleted successfully\", HttpStatus.OK);&#125; Swagger ConfigurationWe need to create a Docket bean in a Spring Boot configuration to configure Swagger 2. A Springfox Docket instance provides the primary API configuration with sensible defaults and convenience methods for configuration.@EnableSwagger2 Indicates that Swagger support should be enabled. This should be applied to a Spring java config and should have an accompanying @Configuration annotation. Loads all required beans defined in @SpringSwaggerConfig Below is minimum configuration required for Swagger. SwaggerConfig123456789101112@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket api() &#123; return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build(); &#125;&#125; Now If we run the application and go to http://localhost:8080/swagger-ui.html documentation will be rendered by Swagger UI. Update Swagger Configuration for Customization - ApInfoApiInfo1234567891011private ApiInfo apinfo() &#123; return new ApiInfoBuilder() .title(\"User Management API\") .description(\"Rest API to Perfrom CURD \") .termsOfServiceUrl(\"Some Terms of Services URL\") .version(\"1.0.0\") .license(\"Some License Info\") .licenseUrl(\"Some License URL\") .contact(new Contact(\"Niraj Sonawane\", \"https://nirajsonawane.github.io/\",\"Niraj.Sonawane@gmail.com\")) .build(); &#125; Update Swagger Configuration for Customization - Selecting Specific EndpointsWhen we verify the Generated documentation, We see that in Basic Error Controller along with our User Controller and Model.We can Configure Swagger to generated documentation only for certain endpoints using RequestHandlerSelectors. The Available options for Configurations are RequestHandlerSelectors.basePackage(basePackage) RequestHandlerSelectors.withClassAnnotation(annotation) RequestHandlerSelectors.withMethodAnnotation(annotation) Swagger Annotations On Controller classesSwagger provides annotations that can be applied on Controller classes to provide additional information,We can annotate controllers and their methods and method parameters. @Api describes the whole controller @ApiOperation is used for description on a methods level @ApiResponses is used for description of response codes on a methods level @ApiParam is used for method parameters Swagger Annotations On Controller classes1234567891011@GetMapping(\"/&#123;id&#125;\")@ApiOperation(consumes=\"application/json\", produces=\"application/json\",protocols=\"http\", value = \"getUser\" )@ApiResponses(value = &#123; @ApiResponse(code = 200, message = \"Successfully retrieved User\"), @ApiResponse(code = 401, message = \"The request has not been applied because it lacks valid authentication credentials for the target resource\"), @ApiResponse(code = 403, message = \"The server understood the request but refuses to authorize it\"), @ApiResponse(code = 404, message = \"The resource not found\")&#125;) public User getUser(@ApiParam(\"Id of user, Can not be null\") @PathVariable int id) &#123; return userservice.getUser(id);&#125; Swagger Annotations On Model classesSwagger Core annotations, Can be used to specify additional information about your model Class.e.g User Class annotated with these annotations can look something like this Swagger Annotations On Model classes12345678910111213141516171819@ApiModel(description = \"Class representing User \")public class User &#123; @ApiModelProperty(notes = \"Unique ID for user\", example = \"1\", required = true, position = 0) private int id; @ApiModelProperty(notes = \"First Name of User\", example = \"Niraj\", required = true, position = 1) private String firstName; @ApiModelProperty(notes = \"Last Name of User\", example = \"Sonawane\", required = true, position = 2) private String lastName; @ApiModelProperty(notes = \"Middle Name of User\", example = \"Ashok\", required = false, position = 3) private String middleName; @ApiModelProperty(notes = \"Age of User\", example = \"32\", required = true, position = 4) private Integer age;&#125; Swagger Integration with JSR-303 AnnotationsJSR 303 Bean Validation is the specification of the Java API for JavaBean validation in Java EE and Java SE. This is very popular mechanism for validation and number of projects are using it.JSR 303 Bean Validation12345678910111213141516@Datapublic class User &#123; private int id; @NotBlank @Size(min = 2, max = 10) private String firstName; @NotBlank private String lastName; private String middleName; @NotNull @Min(2) @Max(100) private Integer age;&#125;This is a common practice which is already widely used. Swagger can be easily configured to read these annotations and generate documentation based on such annotations.This makes Swagger very useful as we can utilize what we already have in our project without writing all the constraints manually. Consumers also know what are restrictions on the values and what they should provide to API and what values to expect. Add dependency in pom file12345 &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-bean-validators&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; Import BeanValidatorPluginsConfiguration12345 @Configuration@EnableSwagger2@Import(BeanValidatorPluginsConfiguration.class)public class SwaggerConfig &#123; After Integration Model will look like below in generated documentation. The code for this post is available for download here.","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://nirajsonawane.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://nirajsonawane.github.io/tags/Spring-Boot/"},{"name":"Swagger","slug":"Swagger","permalink":"https://nirajsonawane.github.io/tags/Swagger/"},{"name":"Rest","slug":"Rest","permalink":"https://nirajsonawane.github.io/tags/Rest/"}]},{"title":"Junit 5 : Write Powerful Unit Test Cases Using Parameterized Tests","slug":"Junit-5-Write-Powerful-Unit-Test-Cases-Using-Parameterized-Tests","date":"2018-12-30T08:57:02.000Z","updated":"2018-12-30T12:49:58.555Z","comments":true,"path":"2018/12/30/Junit-5-Write-Powerful-Unit-Test-Cases-Using-Parameterized-Tests/","link":"","permalink":"https://nirajsonawane.github.io/2018/12/30/Junit-5-Write-Powerful-Unit-Test-Cases-Using-Parameterized-Tests/","excerpt":"","text":"unsplash-logoWellington Rodrigues JUnit 5Unlike previous versions of JUnit. JUnit 5 is complete rewrite and has lot of interesting architecture changes. JUnit 5 is not Single project but compose from three sub-projects: Jupiter, Vintage, and Platform. JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage Check JUnit 5 User Guide For more details. You can find all code samples in on my GitHub Account In this post We will discuss Parameterized Tests in JUnit 5. Parameterized TestsJUnit 5 Parameterized Test are very powerful. With the help of Parameterized Test We can remove the duplication in test cases.Parameterized test cases can also help us to cleanup the test code and remove the cluter.As Name suggest Parameterized tests make it possible to run a test multiple times with different arguments. They are declared just like regular @Test methods but use the @ParameterizedTest annotation instead. In addition, you must declare at least one source that will provide the arguments for each invocation and then consume the arguments in the test method. Simple ParameterizedTestThe following example demonstrates a parameterized test that uses the @ValueSource annotation to specify a String array as the source of arguments. Test Case will be called 2 times with parameter Hello and World.Framework will be responsible for injecting parameter values Simple ParameterizedTest1234567 @ParameterizedTest @ValueSource(strings = &#123; \"Hello\", \"World\" &#125;) void withSomeValues(String word) &#123; System.out.println(word); assertNotNull(word);&#125; Display Names For ParameterizedTestJUnit 5 has added new annotation @DisplayName, Which helps to provide more readable names to test classes and methods.These names will be displayed by test runners and test reporting. Display Names12345678 @DisplayName(\"String should not be null\") @ParameterizedTest @ValueSource(strings = &#123; \"Hello\", \"World\" &#125;) void withSomeValues(String word) &#123; System.out.println(word); assertNotNull(word);&#125; But in case of Parameterized Test,Sometimes we might need to name test cases based on arguments. JUnit 5 provides index and arguments variable for thisDisplay Names For ParameterizedTest12345678 @ParameterizedTest(name = \"Null Check Test #&#123;index&#125; with [&#123;arguments&#125;]\") @ParameterizedTest @ValueSource(strings = &#123; \"Hello\", \"World\" &#125;) void withSomeValues(String word) &#123; System.out.println(word); assertNotNull(word);&#125; Sources of Arguments Out of the box, JUnit Jupiter provides number of Argument Source providers. @ValueSource @EnumSource @MethodSource @CsvSource @CsvFileSource @ArgumentsSource Let’s try one by one @EnumSource@EnumSource provides a convenient way to use Enum constants. This annotation provides an optional names parameter that lets you specify which constants shall be used. If omitted, all constants will be used like in the following example. EnumSource1234567 @ParameterizedTest(name = \"withSomeName #&#123;index&#125; with Value [&#123;arguments&#125;]\") @EnumSource(MyTestEnum.class) void withSomeEnum(MyTestEnum myEnum) &#123; System.out.println(myEnum); assertNotNull(myEnum);&#125; @MethodSource@MethodSource allows you to refer one or more factory methods of the test class or external classes. Method Source in Same class Factory methods within the test class must be static. Each factory method must generate a stream of arguments. MethodSource in Same Class1234567891011 @ParameterizedTest @MethodSource(\"createWordsWithLength\") void withMethodSource(String word, int length) &#123; System.out.println(\"withMethodSource\"); assertNotNull(word);&#125; private static Stream&lt;Arguments&gt; createWordsWithLength() &#123; return Stream.of(Arguments.of(\"Hello\", 5), Arguments.of(\"JUnit 5\", 7)); &#125; Method Source in Other class Factory methods in external classes must be static. Each factory method must generate a stream of arguments. Factory methods must not accept any arguments.MethodSource in external classes12345678910 @ParameterizedTest @MethodSource(\"com.niraj.MethodSource#stringProvider\") void withMethodSource(String word, int length) &#123; System.out.println(\"withMethodSource\"); assertNotNull(word);&#125;private static Stream&lt;Arguments&gt; createWordsWithLength() &#123; return Stream.of(Arguments.of(\"Hello\", 5), Arguments.of(\"JUnit 5\", 7));&#125; @CsvSourceAs name suggest @CsvSource allows you to express argument lists as comma-separated values (i.e., String literals).CsvSource12345 @ParameterizedTest @CsvSource(&#123; \"Hello, 5\", \"World, 5\", \"test,4\" &#125;) void withCsvSource(String word, int length) &#123; assertEquals(word.length(), length);&#125; @CsvFileSourceSimilar to @CsvSource We can also provide csv values using file from classpath @CsvFileSource. CsvFileSource12345 @ParameterizedTest @CsvFileSource(resources = \"/testdata.csv\") void withCsvFileSource(String word, int length) &#123; assertEquals(word.length(), length);&#125; ArgumentsSourceIf any of the above Source provider does not meet your requirement, then you can use your custom Argument Source provider. You will need to implement ArgumentsProvider Interface. ArgumentsSource123456 @ParameterizedTest @ArgumentsSource(StringArgumentsProvider.class) void testWithArgumentsSource(String argument) &#123; assertNotNull(argument); &#125; &#125; StringArgumentsProvider123456public class StringArgumentsProvider implements ArgumentsProvider &#123; @Override public Stream&lt;? extends Arguments&gt; provideArguments(ExtensionContext context) &#123; return Stream.of(\"Hello\", \"world\").map(Arguments::of); &#125; Argument Conversion In all above Test cases you might have observed that the arguments are getting converted to method parameter types. In all examples, arguments are getting converted to String. Who is converting these arguments ? What if we change it to int or any other types? What happens if incase we want to use any User Defined object ? Widening ConversionJUnit Jupiter supports Widening Primitive Conversion for arguments supplied to a @ParameterizedTest. For example, a parameterized test annotated with @ValueSource(ints = { 1, 2, 3 }) can be declared to accept not only an argument of type int but also an argument of type long, float, or double. Explicit ConversionWe Can Specify ArgumentConverter to convert to any user define object. In below example i wanted to convert String “niraj,sonawane” to Person object. ArgumentConverter12345678910111213141516171819202122 @ParameterizedTest @ValueSource(strings =&#123;\"niraj,sonawane\"&#125;) void withCustomConverter(@ConvertWith(PersonConverter.class) Person person) &#123; assertEquals(Person.getFirstName(),\"niraj\"); assertEquals(Person.getLastName(),\"sonawane\"); &#125; //Convert class public class PersonConverter implements ArgumentConverter &#123; @Override public Object convert(Object source, ParameterContext context) throws ArgumentConversionException &#123; if (source instanceof String) try &#123; String[] split = ((String) source).split(\",\"); return new Emp(split[0], split[1]); &#125; catch (NumberFormatException ex) &#123; String message = source + \" is no correct string representation of a Emp.\"; throw new ArgumentConversionException(message, ex); &#125; throw new ArgumentConversionException(source + \" is no valid point\"); &#125;&#125;","categories":[{"name":"Unit Testing","slug":"Unit-Testing","permalink":"https://nirajsonawane.github.io/categories/Unit-Testing/"}],"tags":[{"name":"JUnit-5","slug":"JUnit-5","permalink":"https://nirajsonawane.github.io/tags/JUnit-5/"},{"name":"Unit Testing","slug":"Unit-Testing","permalink":"https://nirajsonawane.github.io/tags/Unit-Testing/"}]},{"title":"Applying Reactive Programing to Existing Batch Application- RXJava2","slug":"Applying-Reactive-Programing-to-Existing-Batch-Application-RXJava2","date":"2018-12-06T05:10:55.000Z","updated":"2018-12-11T15:45:31.299Z","comments":true,"path":"2018/12/06/Applying-Reactive-Programing-to-Existing-Batch-Application-RXJava2/","link":"","permalink":"https://nirajsonawane.github.io/2018/12/06/Applying-Reactive-Programing-to-Existing-Batch-Application-RXJava2/","excerpt":"Today, I will share my experience of migrating our existing Spring batch application to reactive programing model using ReactiveX extensions.The goal is to explain, What is ReactiveX-RXjava2 and demonstrating Working example. What is ReactiveX And RxJavaReactiveX Is An API for asynchronous programming with observable streams.ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming. RxJava is the Java implementation of ReactiveX. RxJava provides Java API for asynchronous programming with observable streams.ReactiveX Why Reactive programming? For Me Reactive Programming is a development model focus around Asynchronous Data Streams. In Reactive programming, Data streams are the center part of your application. Mesages ,Events, Errors ,Event chains ,call etc are going to be conveyed As a data stream. Reactive programming provides a simple way of asynchronous programming. Migration Story","text":"Today, I will share my experience of migrating our existing Spring batch application to reactive programing model using ReactiveX extensions.The goal is to explain, What is ReactiveX-RXjava2 and demonstrating Working example. What is ReactiveX And RxJavaReactiveX Is An API for asynchronous programming with observable streams.ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming. RxJava is the Java implementation of ReactiveX. RxJava provides Java API for asynchronous programming with observable streams.ReactiveX Why Reactive programming? For Me Reactive Programming is a development model focus around Asynchronous Data Streams. In Reactive programming, Data streams are the center part of your application. Mesages ,Events, Errors ,Event chains ,call etc are going to be conveyed As a data stream. Reactive programming provides a simple way of asynchronous programming. Migration Story The Batch application was very traditional use case of file processing. Processing includes Multiple complex Steps.To Stimulate Similar processing with less complexity, I have created small Spring-Batch application that process csv file containing FirstName,LastName and Age. Processing includes below Steps. Validations - Age Should not be more than 100 years. Enrichment 1 - Upper Case First Name. Enrichment 2 - Upper Case Last Name. Segregation - Based on Age, Categories Person As Teenager, YoungAdult or Senior Citizens. Database Insert- Based on Age Group insert person in associate table. The complete source code Spring-Batch ImplementationThe complete source code RXJava2 Implementation Let’s Start with RXJava2 ImplementationBuilding blocks for RxJavaObservables Representing sources of dataSubscribers or observers listening to the observablesOperators Operators create Observables Or Transform data or operate on an Observable and return an Observable set of methods for modifying and composing the data. Step 1 : Creating Observable on Input FileObServable is Responsible for reading data from file and passing it to Subscriber.There are multiple ways by which we create Observable. For reading data from file we will use defer() operator.The defer() operator does not create the Observable until the observer subscribes, and create a fresh Observable for each observer. Create Observable1234567891011121314151617181920212223242526272829 Observable&lt;Person&gt; observable = Observable.defer(() -&gt; new CsvFileObservableSource(filePath))public class CsvFileObservableSource implements ObservableSource&lt;Person&gt; &#123; private static final Logger log = LoggerFactory.getLogger(CsvFileObservableSource.class); private final String filename; CsvFileObservableSource(String filename) &#123; this.filename = filename; &#125; @Override public void subscribe(Observer&lt;? super Person&gt; observer) &#123; try &#123; Files.lines(Paths.get(filename)).forEach(inputLine -&gt; &#123; String[] split = inputLine.split(\",\"); //Send data observer.onNext( Person.builder() .firstName(split[0]) .lastName(split[1]) .age(Integer.parseInt(split[2])) .build()); &#125;); observer.onComplete(); // No more data to be send &#125; catch (IOException e) &#123; observer.onError(e); // Some error , send error information to subscriber. &#125; &#125;&#125; Step 2 : Subscribe to Observableobservable.subscribe(onNext,onError,onComplete);Provide onNext,onError,onComplete consumersThe Subscriber will print the values line by line read from file.12345observable.subscribe( person -&gt; System.out::println, Throwable::printStackTrace, () -&gt; System.out::println(\"I am Done\"); ); Step 3 : Add Processing logic using OperatorsNow Process the elements read from the file using operators like filter &amp; map This is similar to java 8 stream.123456final Observable&lt;List&lt;Person&gt;&gt; observable = Observable.defer(() -&gt; new CsvFileObservableSource(filePath)) .filter(ValidationProcessor::process) .map(FirstNameProcessor::process) .map(LastNameProcessor::process) .map(AgeProcessor::process) .buffer(chunkSize);Note If you observe,Observable is of Type List&lt;Person&gt; instead of &lt;Person&gt; . This is because we want to process data in chunk and not as individual data item. This capability is provided by buffer operator. Bufferperiodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a time. Step 4 : Group Person elements and Insert in different TablesNow Based on Age, We want to Categories Person As Teenager, YoungAdult or Senior Citizens.GroupBy OperatorDivide an Observable into a set of Observables that each emit a different subset of items from the original Observable.123456789101112131415161718192021 Observable&lt;GroupedObservable&lt;String, Person&gt;&gt; groupObservable = Observable .defer(() -&gt; new CsvFileObservableSource(filePath)) .filter(ValidationProcessor::process) .map(FirstNameProcessor::process) .map(LastNameProcessor::process) .map(AgeProcessor::process) .groupBy(Person::getAgeGroup);groupObservable.subscribe(s -&gt; &#123; if (\"TEENAGER\".equals(s.getKey())) &#123; s.buffer(chunkSize).subscribe(daoServiceImpl::insertTeenagerList); &#125; if (\"YOUNGADULT\".equals(s.getKey())) &#123; s.buffer(chunkSize).subscribe(daoServiceImpl::insertYoungadultList); &#125; if (\"SENIORCITIZENS\".equals(s.getKey())) &#123; s.buffer(chunkSize).subscribe(daoServiceImpl::insertSeniorcitizensList); &#125; &#125;, Throwable::printStackTrace, () -&gt; &#123; System.out.println(\"File Processing Complited\"); &#125;);The complete source code RXJava2 Implementation There are other important aspect like Error Handling, Backpressure and Multithreading are not in scope of this article. I will try to cover them in upcoming articles.","categories":[{"name":"RXJava-2","slug":"RXJava-2","permalink":"https://nirajsonawane.github.io/categories/RXJava-2/"}],"tags":[{"name":"RXjava","slug":"RXjava","permalink":"https://nirajsonawane.github.io/tags/RXjava/"},{"name":"ReactiveX","slug":"ReactiveX","permalink":"https://nirajsonawane.github.io/tags/ReactiveX/"},{"name":"Functional Programming","slug":"Functional-Programming","permalink":"https://nirajsonawane.github.io/tags/Functional-Programming/"},{"name":"Reactive Programming","slug":"Reactive-Programming","permalink":"https://nirajsonawane.github.io/tags/Reactive-Programming/"},{"name":"Streams","slug":"Streams","permalink":"https://nirajsonawane.github.io/tags/Streams/"}]},{"title":"Spring Batch - Process Multiple Files Parallel","slug":"Spring-Batch-Process-Multiple-Files-Parallel","date":"2018-11-08T11:47:22.000Z","updated":"2018-12-11T15:49:42.379Z","comments":true,"path":"2018/11/08/Spring-Batch-Process-Multiple-Files-Parallel/","link":"","permalink":"https://nirajsonawane.github.io/2018/11/08/Spring-Batch-Process-Multiple-Files-Parallel/","excerpt":"Photo Credit Pixabay Today, We will discuss how we can Process Multiple Files Concurrently using Spring Batch. Prerequisite Basic knowledge of Spring &amp; Spring Batch Framework is Required. BackgroundSpring Batch is a lightweight, comprehensive batch framework designed to enable the development of robust batch applications vital for the daily operations of enterprise systems. Spring Batch builds upon the characteristics of the Spring Framework that people have come to expect (productivity, POJO-based development approach, and general ease of use), while making it easy for developers to access and leverage more advance enterprise services when necessary. Scaling and Parallel Processing Spring Batch Offers Multiple options for Scaling and Parallel Processing. At very high level these are separated in below categories. Multi-threaded Step Parallel Steps Remote Chunking Partitioning For Processing Multiple Files we will be using Partitioning. PartitioningThe Job is executing on the left hand side as a sequence of Steps, and one of the Steps is labelled as a Master. The Slaves in this picture are all identical instances of a Step, which could in fact take the place of the Master resulting in the same outcome for the Job. The Slaves are typically going to be remote services, but could also be local threads of execution. The messages sent by the Master to the Slaves in this pattern do not need to be durable, or have guaranteed delivery: Spring Batch meta-data in the JobRepository will ensure that each Slave is executed once and only once for each Job execution.If required, we can pass data from the master to the slave. The meta data (i.e. the JobRepository), makes sure that every slave is executed only once in a single execution of the Job.","text":"Photo Credit Pixabay Today, We will discuss how we can Process Multiple Files Concurrently using Spring Batch. Prerequisite Basic knowledge of Spring &amp; Spring Batch Framework is Required. BackgroundSpring Batch is a lightweight, comprehensive batch framework designed to enable the development of robust batch applications vital for the daily operations of enterprise systems. Spring Batch builds upon the characteristics of the Spring Framework that people have come to expect (productivity, POJO-based development approach, and general ease of use), while making it easy for developers to access and leverage more advance enterprise services when necessary. Scaling and Parallel Processing Spring Batch Offers Multiple options for Scaling and Parallel Processing. At very high level these are separated in below categories. Multi-threaded Step Parallel Steps Remote Chunking Partitioning For Processing Multiple Files we will be using Partitioning. PartitioningThe Job is executing on the left hand side as a sequence of Steps, and one of the Steps is labelled as a Master. The Slaves in this picture are all identical instances of a Step, which could in fact take the place of the Master resulting in the same outcome for the Job. The Slaves are typically going to be remote services, but could also be local threads of execution. The messages sent by the Master to the Slaves in this pattern do not need to be durable, or have guaranteed delivery: Spring Batch meta-data in the JobRepository will ensure that each Slave is executed once and only once for each Job execution.If required, we can pass data from the master to the slave. The meta data (i.e. the JobRepository), makes sure that every slave is executed only once in a single execution of the Job.Demo Application For processing Multiple Files Concurrently We will extend the Spring Batch Sample Application provided on Getting Stated guide Here Sample Application : Sample application imports data from a CSV spreadsheet, transforms it with custom code, and stores the final results in a database. We will add the capability of Processing Multiple Files Concurrently Step by Step. Defining Partitioner bean using MultiResourcePartitionerMultiResourcePartitioner is Implementation of Partitioner that locates multiple resources and associates their file names with execution context keys. Creates an ExecutionContext per resource, and labels them as {partition0, partition1, …, partitionN}.MultiResourcePartitioner Bean Configuration12345678910111213141516 @Bean(\"partitioner\")@StepScopepublic Partitioner partitioner() &#123; log.info(\"In Partitioner\"); MultiResourcePartitioner partitioner = new MultiResourcePartitioner(); ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); Resource[] resources = null; try &#123; resources = resolver.getResources(\"/*.csv\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; partitioner.setResources(resources); partitioner.partition(10); return partitioner;&#125;Configuration of Master StepMaster Step & TaskExcecutor Configuration12345678910111213141516171819@Bean @Qualifier(\"masterStep\") public Step masterStep() &#123; return stepBuilderFactory.get(\"masterStep\") .partitioner(\"step1\", partitioner()) .step(step1()) .taskExecutor(taskExecutor()) .build(); &#125; @Bean public ThreadPoolTaskExecutor taskExecutor() &#123; ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setMaxPoolSize(10); taskExecutor.setCorePoolSize(10); taskExecutor.setQueueCapacity(10); taskExecutor.afterPropertiesSet(); return taskExecutor; &#125;Binding Input Data to Steps: Passing File NameThis can be done using StepScope feature of Spring Batch.StepScope Allows the late binding.We need to Read filename from the stepExecutionContext as shown below.FlatFileItemReader Configuration123456789101112131415161718 @Bean@StepScope@Qualifier(\"personItemReader\")public FlatFileItemReader&lt;Person&gt; personItemReader(@Value(\"#&#123;stepExecutionContext['fileName']&#125;\") String filename) throws MalformedURLException &#123; log.info(\"In Reader\"); return new FlatFileItemReaderBuilder&lt;Person&gt;() .name(\"personItemReader\") .delimited() .names(new String[] &#123; \"firstName\", \"lastName\" &#125;) .fieldSetMapper(new BeanWrapperFieldSetMapper&lt;Person&gt;() &#123; &#123; setTargetType(Person.class); &#125; &#125;) .resource(new UrlResource(filename)) .build();&#125;Configuration of slave StepSlave Step Configuration123456789 @Beanpublic Step step1() &#123; return stepBuilderFactory.get(\"step1\") .&lt;Person, Person&gt;chunk(10) .processor(processor()) .writer(writer) .reader(personItemReader) .build();&#125;Now if we Launch the application, In logs we can see each file is getting process by separate thread. References Spring Batch getting Started Scaling and Parallel ProcessingPartitioningGithub Link of Solution","categories":[{"name":"Spring-Batch","slug":"Spring-Batch","permalink":"https://nirajsonawane.github.io/categories/Spring-Batch/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nirajsonawane.github.io/tags/Spring/"},{"name":"Spring-Batch","slug":"Spring-Batch","permalink":"https://nirajsonawane.github.io/tags/Spring-Batch/"}]},{"title":"Angular Material Tabs with Router","slug":"Angular-Material-Tabs-with-Router","date":"2018-10-27T04:28:55.000Z","updated":"2018-12-11T15:48:18.176Z","comments":true,"path":"2018/10/27/Angular-Material-Tabs-with-Router/","link":"","permalink":"https://nirajsonawane.github.io/2018/10/27/Angular-Material-Tabs-with-Router/","excerpt":"In this article, I will show you how to Use Angular Material Tab Component with Angular Routing. The Article is based on Angular 6.We will Create small application using angular cli and will add needed component step by step. Step 1: Create Angular 6 ProjectRun the command in angular cli1ng new angular-material-tab-router Step 2: Add Angular material to projectRun the command in angular cli1npm install --save @angular/material @angular/cdk @angular/animations Step 3: Add Angular PreBuild Theme to project.We will be using indigo-pink Theme.styless.css1@import \"~@angular/material/prebuilt-themes/indigo-pink.css\";","text":"In this article, I will show you how to Use Angular Material Tab Component with Angular Routing. The Article is based on Angular 6.We will Create small application using angular cli and will add needed component step by step. Step 1: Create Angular 6 ProjectRun the command in angular cli1ng new angular-material-tab-router Step 2: Add Angular material to projectRun the command in angular cli1npm install --save @angular/material @angular/cdk @angular/animations Step 3: Add Angular PreBuild Theme to project.We will be using indigo-pink Theme.styless.css1@import \"~@angular/material/prebuilt-themes/indigo-pink.css\"; Step 4: Add BrowserAnimationsModuleapp.module.ts1import &#123;BrowserAnimationsModule&#125; from '@angular/platform-browser/animations'; Step 5: Add Angular Material Toolbar &amp; Tabs.In the most situations, a Material toolbar will be placed at the top of your application and will only have a single row that includes the title of your application. app.component.html1234&lt;mat-toolbar color=\"primary\"&gt;&lt;span&gt; Angular Material App With Tab and Routing &lt;/span&gt;&lt;span class=\"example-fill-remaining-space\"&gt;&lt;/span&gt; &lt;/mat-toolbar&gt; Angular Material Tabs organize content into separate views where only one view can be visible at a time. Each tab’s label is shown in the tab header and the active tab’s label is designated with the animated ink bar. When the list of tab labels exceeds the width of the header, pagination controls appear to let the user scroll left and right across the labels.app.component.html12345&lt;mat-tab-group&gt;&lt;mat-tab label=&quot;First&quot;&gt; Content 1 &lt;/mat-tab&gt;&lt;mat-tab label=&quot;Second&quot;&gt; Content 2 &lt;/mat-tab&gt;&lt;mat-tab label=&quot;Third&quot;&gt; Content 3 &lt;/mat-tab&gt;&lt;/mat-tab-group&gt; Add corresponding imports in app.module.tsapp.module.ts123456789101112import &#123;MatToolbarModule&#125; from &apos;@angular/material/toolbar&apos;;import &#123;MatTabsModule&#125; from &apos;@angular/material/tabs&apos;;import &#123;BrowserAnimationsModule&#125; from &apos;@angular/platform-browser/animations&apos;; imports: [ BrowserModule, MatToolbarModule, MatTabsModule, BrowserAnimationsModule, AppRoutingModule, ], Now we have integrated Material MatTabsModule in our application. Start applicationng serve Step 6: Add Routing module to applicationAn Angular best practice is to load and configure the router in a separate, top-level module that is dedicated to routing and imported by the root AppModule.By convention, the module class name is AppRoutingModule and it belongs in the app-routing.module.ts in the src/app folder.Run the command in angular cli1234567ng generate module app-routing --flat --module=app//Also generate some test component using cli ng generate component componenet1ng generate component componenet2ng generate component componenet3 Step 7: Initialize and Add RoutesRoutes tell the router which view to display when a user clicks a link or pastes a URL into the browser address bar.A typical Angular Route has two properties: Path: a string that matches the URL in the browser address bar. Component: the component that the router should create when navigating to this route. This is how the app-routing.module.ts will look like after adding routes.app-routing.module.ts12345678910111213141516171819202122import &#123; NgModule &#125; from '@angular/core';import &#123; CommonModule &#125; from '@angular/common';import &#123; RouterModule, Routes &#125; from '@angular/router';import &#123; Componenet1Component &#125; from './componenet1/componenet1.component';import &#123; Componenet2Component &#125; from './componenet2/componenet2.component';import &#123; Componenet3Component &#125; from './componenet3/componenet3.component';const routes: Routes = [ &#123; path: '', redirectTo: '/first', pathMatch: 'full' &#125;, &#123; path: 'first', component: Componenet1Component&#125;, &#123; path: 'second', component: Componenet2Component&#125;, &#123; path: 'third', component: Componenet3Component&#125;,];export const appRouting = RouterModule.forRoot(routes);@NgModule(&#123; imports: [ RouterModule.forRoot(routes), CommonModule ], exports: [ RouterModule ], declarations: []&#125;)export class AppRoutingModule &#123; &#125; Step 7 : Tabs and NavigationWhile &lt;mat-tab-group&gt; is used to switch between views within a single route, &lt;nav mat-tab-nav-bar&gt; provides a tab-like UI for navigating between routes.let’s update &lt;mat-tab-group&gt; to &lt;nav mat-tab-nav-bar&gt; app.component.html12345678910&lt;nav mat-tab-nav-bar&gt;&lt;a mat-tab-link*ngFor=\"let link of navLinks\"[routerLink]=\"link.link\"routerLinkActive #rla=\"routerLinkActive\"[active]=\"rla.isActive\"&gt;&lt;/a&gt;&lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; Setup navLinks In the app.component.ts , I have initialized navLinks with a routeLinks array in the constructor. Also note that ngOnInit() function is responsible to maintaining Tab selection. AppComponent.ts1234567891011121314151617181920212223242526272829303132333435import &#123; Component &#125; from '@angular/core';import &#123;MatToolbarModule&#125; from '@angular/material/toolbar';import &#123; Router &#125; from '@angular/router';@Component(&#123; selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css']&#125;)export class AppComponent &#123; title = 'angular-material-tab-router'; navLinks: any[]; activeLinkIndex = -1; constructor(private router: Router) &#123; this.navLinks = [ &#123; label: 'First', link: './first', index: 0 &#125;, &#123; label: 'Second', link: './second', index: 1 &#125;, &#123; label: 'Third', link: './third', index: 2 &#125;, ];&#125;ngOnInit(): void &#123; this.router.events.subscribe((res) =&gt; &#123; this.activeLinkIndex = this.navLinks.indexOf(this.navLinks.find(tab =&gt; tab.link === '.' + this.router.url)); &#125;);&#125;&#125; Working application will look like below References Material ComponentsAngular Github Link of Solution","categories":[{"name":"Angular","slug":"Angular","permalink":"https://nirajsonawane.github.io/categories/Angular/"}],"tags":[{"name":"Angular6","slug":"Angular6","permalink":"https://nirajsonawane.github.io/tags/Angular6/"},{"name":"Material","slug":"Material","permalink":"https://nirajsonawane.github.io/tags/Material/"},{"name":"Navigation","slug":"Navigation","permalink":"https://nirajsonawane.github.io/tags/Navigation/"},{"name":"Routing","slug":"Routing","permalink":"https://nirajsonawane.github.io/tags/Routing/"}]},{"title":"Java 8 Custom Collector","slug":"Java-8-Custom-Collector","date":"2018-09-11T02:52:10.000Z","updated":"2018-12-11T15:48:55.516Z","comments":true,"path":"2018/09/11/Java-8-Custom-Collector/","link":"","permalink":"https://nirajsonawane.github.io/2018/09/11/Java-8-Custom-Collector/","excerpt":"In this Article , we’ll Discuss How we can Create our own Custom Collector in java 8 and above.For this article, We will implement Summary Statistics For BigDecimal number. Java 8 Summary StatisticsJava 8 Provides Summary Statistics for Long,Int &amp; Double. These Summary classes will help you to get count, min, max, sum, and average values. LongSummaryStatistics IntSummaryStatistics DoubleSummaryStatistics IntSummaryStatistics ExampleIn below example we are trying to calculate count, min, max, sum, and average of 1 to 100 Integer. Calculate Sum,Min,Max,Count & Average12345IntSummaryStatistics summaryStatistics = IntStream.range(1, 101) .summaryStatistics(); System.out.println(summaryStatistics);","text":"In this Article , we’ll Discuss How we can Create our own Custom Collector in java 8 and above.For this article, We will implement Summary Statistics For BigDecimal number. Java 8 Summary StatisticsJava 8 Provides Summary Statistics for Long,Int &amp; Double. These Summary classes will help you to get count, min, max, sum, and average values. LongSummaryStatistics IntSummaryStatistics DoubleSummaryStatistics IntSummaryStatistics ExampleIn below example we are trying to calculate count, min, max, sum, and average of 1 to 100 Integer. Calculate Sum,Min,Max,Count & Average12345IntSummaryStatistics summaryStatistics = IntStream.range(1, 101) .summaryStatistics(); System.out.println(summaryStatistics); implementing SummaryStatistics for Big Decimal numbersJava does not provides inbuilt Summary Statistics class for BigDecimal Number. Lets try to implement our own BigDecimal SummaryStatistics. Step 1 : Create Collector Calculate Sum,Min,Max,Count & Average123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.math.BigDecimal;import java.util.function.Consumer;import java.util.stream.Collector;public class MyBigDecimalSummaryCollector implements Consumer&lt;BigDecimal&gt; &#123; public static final int ROUND_HALF_UP = BigDecimal.ROUND_HALF_UP; public static final Integer TRANSACTIONS_SCALE = 2; private BigDecimal sum = BigDecimal.ZERO.setScale(TRANSACTIONS_SCALE, ROUND_HALF_UP); private BigDecimal minimum = BigDecimal.ZERO.setScale(TRANSACTIONS_SCALE, ROUND_HALF_UP); private BigDecimal maximum = BigDecimal.ZERO.setScale(TRANSACTIONS_SCALE, ROUND_HALF_UP); private int count; public static Collector&lt;BigDecimal, ?, MyBigDecimalSummaryCollector&gt; myBigDecimalSummaryStatistics() &#123; return Collector.of(MyBigDecimalSummaryCollector::new, MyBigDecimalSummaryCollector::accept, MyBigDecimalSummaryCollector::merge); &#125; @Override public void accept(BigDecimal t) &#123; if (count == 0) &#123; firstElementSetup(t); &#125; else &#123; sum = sum.add(t); minimum = minimum.min(t); maximum = maximum.max(t); count++; &#125; &#125; public MyBigDecimalSummaryCollector merge(MyBigDecimalSummaryCollector s) &#123; if (s.count &gt; 0) &#123; if (count == 0) &#123; setupFirstElement(s); &#125; else &#123; sum = sum.add(s.sum); minimum = minimum.min(s.minimum); maximum = maximum.max(s.maximum); count += s.count; &#125; &#125; return this; &#125; private void setupFirstElement(MyBigDecimalSummaryCollector s) &#123; count = s.count; sum = s.sum; minimum = s.minimum; maximum = s.maximum; &#125; private void firstElementSetup(BigDecimal t) &#123; count = 1; sum = t; minimum = t; maximum = t; &#125; public BigDecimal getAverage() &#123; if (count == 0) &#123; return BigDecimal.ZERO.setScale(TRANSACTIONS_SCALE, ROUND_HALF_UP); &#125; return sum.divide(BigDecimal.valueOf(count), TRANSACTIONS_SCALE, ROUND_HALF_UP); &#125; public BigDecimal getSum() &#123; return sum; &#125; public void setSum(BigDecimal sum) &#123; this.sum = sum; &#125; public BigDecimal getMinimum() &#123; return minimum; &#125; public void setMinimum(BigDecimal minimum) &#123; this.minimum = minimum; &#125; public BigDecimal getMaximum() &#123; return maximum; &#125; public void setMaximum(BigDecimal maximum) &#123; this.maximum = maximum; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; @Override public String toString() &#123; return \"MyBigDecimalSummaryCollector [sum=\" + sum + \", minimum=\" + minimum + \", maximum=\" + maximum + \", count=\" + count + \"]\"; &#125;&#125; Step 2 : Use Collector1234567MyBigDecimalSummaryCollector collect = IntStream.range(1, 101) .mapToObj(number -&gt; BigDecimal.valueOf(number)) .collect(MyBigDecimalSummaryCollector.myBigDecimalSummaryStatistics()); System.out.println(collect);","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Collector","slug":"Java-8/Collector","permalink":"https://nirajsonawane.github.io/categories/Java-8/Collector/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Java-9","slug":"Java-9","permalink":"https://nirajsonawane.github.io/tags/Java-9/"},{"name":"Collector","slug":"Collector","permalink":"https://nirajsonawane.github.io/tags/Collector/"},{"name":"Bigdecimal","slug":"Bigdecimal","permalink":"https://nirajsonawane.github.io/tags/Bigdecimal/"},{"name":"Summary Statistics","slug":"Summary-Statistics","permalink":"https://nirajsonawane.github.io/tags/Summary-Statistics/"}]},{"title":"Sort Map by Value using Custom Comparator","slug":"Sort-Map-by-Value-using-Custom-Comparator","date":"2018-09-10T08:33:33.000Z","updated":"2018-09-10T22:46:48.000Z","comments":true,"path":"2018/09/10/Sort-Map-by-Value-using-Custom-Comparator/","link":"","permalink":"https://nirajsonawane.github.io/2018/09/10/Sort-Map-by-Value-using-Custom-Comparator/","excerpt":"","text":"In this Article , we’ll Discuss How we can Sort map by Value using Comparator in java 8. Name class as key of HashMap12345public class Name &#123; private String firstName; private String lastName; //builder &#125; Name class as key of HashMap123456 public class Age &#123; private Integer year; private Integer month; //builder&#125; We want to sort Map by Age.Year. Sort map by value using Comparator123456789101112131415161718192021222324252627282930 Map&lt;Name, Age&gt; map = new HashMap&lt;&gt;();Name name0 = Name.builder().firstName(\"Zendor\").lastName(\"Sonawane\").build();Name name1 = Name.builder().firstName(\"Niraj\").lastName(\"Sonawane\").build();Name name2 = Name.builder().firstName(\"Pratik\").lastName(\"Sonawane\").build();Name name3 = Name.builder().firstName(\"Jeetesh\").lastName(\"Sonawane\").build();Name name4 = Name.builder().firstName(\"Rahul\").lastName(\"Sonawane\").build();Name name5 = Name.builder().firstName(\"Amit\").lastName(\"Sonawane\").build();Age age0 = Age.builder().year(30).month(5).build();Age age1 = Age.builder().year(66).month(3).build();Age age2 = Age.builder().year(17).month(6).build();Age age3 = Age.builder().year(3).month(5).build();Age age4 = Age.builder().year(50).month(5).build();Age age5 = Age.builder().year(80).month(12).build();map.put(name0,age0);map.put(name1,age1);map.put(name2,age2);map.put(name3,age3);map.put(name4,age4);map.put(name5,age5);Comparator&lt;Age&gt; byAge = (Age obj1,Age obj2) -&gt; obj1.getYear().compareTo(obj2.getYear());LinkedHashMap&lt;Name, Age&gt; sortedMap = map.entrySet().stream() .sorted(Map.Entry.&lt;Name,Age&gt;comparingByValue(byAge)) .collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue,(e1,e2)-&gt;e1,LinkedHashMap::new)); Source Code Github Link","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Stream","slug":"Java-8/Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Stream","slug":"Stream","permalink":"https://nirajsonawane.github.io/tags/Stream/"},{"name":"Map","slug":"Map","permalink":"https://nirajsonawane.github.io/tags/Map/"},{"name":"Sorting","slug":"Sorting","permalink":"https://nirajsonawane.github.io/tags/Sorting/"},{"name":"Comparator","slug":"Comparator","permalink":"https://nirajsonawane.github.io/tags/Comparator/"}]},{"title":"Sort Map by key using Custom Comparator","slug":"Sort-Map-by-key-using-Custom-Comparator","date":"2018-09-10T08:33:18.000Z","updated":"2018-09-10T22:16:34.000Z","comments":true,"path":"2018/09/10/Sort-Map-by-key-using-Custom-Comparator/","link":"","permalink":"https://nirajsonawane.github.io/2018/09/10/Sort-Map-by-key-using-Custom-Comparator/","excerpt":"","text":"In this Article , we’ll Discuss How we can Sort map by Custom key or Comparator in java 8. We want to sort below Map by FirstName. Name object is used as key for Map. Name class as key of HashMap12345public class Name &#123; private String firstName; private String lastName; //builder &#125; Sort map by Key using Comparator123456789101112131415 Map&lt;Name, Integer&gt; map = new HashMap&lt;&gt;();Name name0 = Name.builder().firstName(\"Zendor\").lastName(\"Sonawane\").build();Name name1 = Name.builder().firstName(\"Niraj\").lastName(\"Sonawane\").build();Name name2 = Name.builder().firstName(\"Pratik\").lastName(\"Sonawane\").build();Name name3 = Name.builder().firstName(\"Jeetesh\").lastName(\"Sonawane\").build();Name name4 = Name.builder().firstName(\"Rahul\").lastName(\"Sonawane\").build();Name name5 = Name.builder().firstName(\"Amit\").lastName(\"Sonawane\").build();map.put(name0,55);map.put(name1,1);map.put(name2,2);map.put(name3,3);map.put(name4,4);map.put(name5,5); This is how we can do that Sort map by Key using Comparator123456Comparator&lt;Name&gt; byName = (Name o1, Name o2)-&gt; o1.getFirstName().compareTo(o2.getFirstName()); LinkedHashMap&lt;Name, Integer&gt; sortedMap = map.entrySet().stream() .sorted(Map.Entry.&lt;Name,Integer&gt;comparingByKey(byName)) .collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue,(e1,e2)-&gt;e1,LinkedHashMap::new)); Source Code Github Link","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Stream","slug":"Java-8/Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Stream","slug":"Stream","permalink":"https://nirajsonawane.github.io/tags/Stream/"},{"name":"Map","slug":"Map","permalink":"https://nirajsonawane.github.io/tags/Map/"},{"name":"Sorting","slug":"Sorting","permalink":"https://nirajsonawane.github.io/tags/Sorting/"},{"name":"Comparator","slug":"Comparator","permalink":"https://nirajsonawane.github.io/tags/Comparator/"}]},{"title":"Java Stream - Sort map by value","slug":"Java-Stream-Sort-map-by-value","date":"2018-09-09T18:25:43.000Z","updated":"2018-09-10T21:56:46.000Z","comments":true,"path":"2018/09/09/Java-Stream-Sort-map-by-value/","link":"","permalink":"https://nirajsonawane.github.io/2018/09/09/Java-Stream-Sort-map-by-value/","excerpt":"","text":"In this Article , we’ll Discuss How we can Sort map by Value in java 8. We want to sort below Map by ValueSort map by Value1234567Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"Niraj\", 6); map.put(\"Rahul\", 43); map.put(\"Ram\", 44); map.put(\"Sham\", 33); map.put(\"Pratik\", 5); map.put(\"Ashok\", 5); Map Sorting using comparingByValue in Ascending orderSort map by Value Ascending order1234Map&lt;String, Integer&gt; sortedMapByValueAscending = map.entrySet().stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1,LinkedHashMap::new)); Map Sorting using comparingByValue in Descending order. For Descending order you need to use reversed()Sort map by Value Descending order1234Map&lt;String, Integer&gt; sortedMapByValueDescending = map.entrySet().stream() .sorted(Map.Entry.&lt;String,Integer&gt;comparingByValue().reversed()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1 ,LinkedHashMap::new)); Source Code Github Link","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Stream","slug":"Java-8/Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Stream","slug":"Stream","permalink":"https://nirajsonawane.github.io/tags/Stream/"},{"name":"Map","slug":"Map","permalink":"https://nirajsonawane.github.io/tags/Map/"},{"name":"Sorting","slug":"Sorting","permalink":"https://nirajsonawane.github.io/tags/Sorting/"}]},{"title":"Java Stream - Sort map by key","slug":"Java-Stream-Sort-map-by-key","date":"2018-09-09T18:25:24.000Z","updated":"2018-10-30T07:38:20.000Z","comments":true,"path":"2018/09/09/Java-Stream-Sort-map-by-key/","link":"","permalink":"https://nirajsonawane.github.io/2018/09/09/Java-Stream-Sort-map-by-key/","excerpt":"","text":"Photo by Anton Lecock on UnsplashIn this Article , we’ll Discuss How we can Sort map by key in java 8.We want to sort below Map by keySort map by Key1234567Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"Niraj\", 6); map.put(\"Rahul\", 43); map.put(\"Ram\", 44); map.put(\"Sham\", 33); map.put(\"Pratik\", 5); map.put(\"Ashok\", 5); Map Sorting using comparingByKey in Ascending orderSort map by Key Ascending order1234Map&lt;String, Integer&gt; sortedMapByValueAscending = map.entrySet() .stream().sorted(Map.Entry.comparingByKey()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1,LinkedHashMap::new)); Map Sorting using comparingByKey in Descending order. For Descending order you need to use reversed()Sort map by Key Descending order1234Map&lt;String, Integer&gt; sortedMapByValueDescending = map.entrySet() .stream().sorted(Map.Entry.&lt;String,Integer&gt;comparingByKey().reversed()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1 ,LinkedHashMap::new)); Source Code Github Link","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Stream","slug":"Java-8/Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Stream","slug":"Stream","permalink":"https://nirajsonawane.github.io/tags/Stream/"},{"name":"Map","slug":"Map","permalink":"https://nirajsonawane.github.io/tags/Map/"},{"name":"Sorting","slug":"Sorting","permalink":"https://nirajsonawane.github.io/tags/Sorting/"}]},{"title":"Angular pipes","slug":"Angular-pipes","date":"2018-08-05T14:33:17.000Z","updated":"2018-10-27T22:49:40.000Z","comments":true,"path":"2018/08/05/Angular-pipes/","link":"","permalink":"https://nirajsonawane.github.io/2018/08/05/Angular-pipes/","excerpt":"","text":"Angular Pipes are used to transforms texts.A pipe takes in data as input and transforms it to a desired output LowerCase PipeTransforms text to all lower case. It is used as follows. {{value_expression | lowercase }} UpperCase PipeTransforms text to all Upper case. It is used as follows. {{ value_expression | uppercase }} TitleCasePipeTransforms text to title case. Capitalizes the first letter of each word, and transforms the rest of the word to lower case. Words are delimited by any whitespace character, such as a space, tab, or line-feed character. {{ value_expression | titlecase }} Date PipeConverts the Date to human-friendly date CurrencyPipeTransforms a number to a currency string, formatted according to locale rules that determine group sizing and separator, decimal-point character, and other locale-specific configurations.","categories":[{"name":"Angular","slug":"Angular","permalink":"https://nirajsonawane.github.io/categories/Angular/"}],"tags":[{"name":"Angular6","slug":"Angular6","permalink":"https://nirajsonawane.github.io/tags/Angular6/"},{"name":"Pipes","slug":"Pipes","permalink":"https://nirajsonawane.github.io/tags/Pipes/"}]},{"title":"Kotlin Smart Casts","slug":"Kotlin-Smart-Casts","date":"2018-07-30T16:46:36.000Z","updated":"2018-07-31T13:59:46.000Z","comments":true,"path":"2018/07/30/Kotlin-Smart-Casts/","link":"","permalink":"https://nirajsonawane.github.io/2018/07/30/Kotlin-Smart-Casts/","excerpt":"","text":"Many times while working we need to check if an object is of certain type at runtime. In java we have instanceof operator to check whether the object is an instance of the specified type. instanceof Java Example123456public class InstanceofExample &#123; public static void main(String[] args) &#123; MyClass obj=new MyClass(); System.out.println(obj instanceof MyClass);//true &#125;&#125; In Kotlin, You can check whether an object is of a certain type at runtime by using the is operator. is operator Kotlin Example123456789if (obj is String) &#123; print(obj.length)&#125;if (obj !is String) &#123; // same as !(obj is String)print(\"Not a String\")&#125;else &#123;print(obj.length)&#125; Smart CastsKotlin Complier is quite smart and help us to avoid boilerplate code. In many cases we do not need to use explicit cast operators , because the compiler tracks the is -checks and explicit casts for immutable values and inserts (safe) casts automatically when needed: Smart Casts Kotlin Example12345fun demo(x: Any) &#123; if (x is String) &#123; print(x.length) // x is automatically cast to String &#125;&#125; The compiler is smart enough to know a cast to be safe if a negative check leads to a return:Smart Casts Kotlin Example12if (x !is String) return print(x.length) // x is automatically cast to String Such smart casts work for when-expressions and while-loops as well:Smart Casts Kotlin Example12345when (x) &#123; is Int -&gt; print(x + 1) is String -&gt; print(x.length + 1) is IntArray -&gt; print(x.sum()) &#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://nirajsonawane.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://nirajsonawane.github.io/tags/Kotlin/"},{"name":"Smart Casts","slug":"Smart-Casts","permalink":"https://nirajsonawane.github.io/tags/Smart-Casts/"},{"name":"Kotlin Types","slug":"Kotlin-Types","permalink":"https://nirajsonawane.github.io/tags/Kotlin-Types/"}]},{"title":"Remove Optional Empty/Null values from list","slug":"Remove-Optional-Empty-null-values-from-list","date":"2018-06-21T06:19:10.000Z","updated":"2018-07-31T06:09:44.000Z","comments":true,"path":"2018/06/21/Remove-Optional-Empty-null-values-from-list/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/21/Remove-Optional-Empty-null-values-from-list/","excerpt":"","text":"In this Article , we’ll Discuss, How we can Convert Stream of Optional elements to a Stream of present value elements. Java 8 has added Optional type to avoid null pointer exception. lets say we have List&lt;Optional&lt;String&gt;&gt; and for further processing we want List&lt;Strings&gt;.In This case we need to remove the null and empty elements from stream and convert it into a Stream of present value elements. Convert Stream of Optional elements to a Stream of present value elements123456789101112131415161718//Input List List&lt;Optional&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();list.add(Optional.empty());list.add(Optional.of(\"Str1\"));list.add(Optional.of(\"Str2\"));list.add(Optional.empty());list.add(Optional.ofNullable(null));//Using FilterList&lt;String&gt; listWithoutNull = list.stream() .filter(Optional::isPresent) .map(obj -&gt;obj.get()) .collect(Collectors.toList());//Using removeIf (if that list supports removal ) list.removeIf(iteam-&gt;!iteam.isPresent()); Java 9In java 9 We can easily convert Stream of optionals to a stream of present values.Using newly addded Optional::stream API java 9123List&lt;String&gt; listWithoutNull = list.stream() .flatMap(Optional::stream) .collect(Collectors.toList());","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Stream","slug":"Java-8/Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/"},{"name":"Filter","slug":"Java-8/Stream/Filter","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/Filter/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Java-9","slug":"Java-9","permalink":"https://nirajsonawane.github.io/tags/Java-9/"},{"name":"Optional","slug":"Optional","permalink":"https://nirajsonawane.github.io/tags/Optional/"},{"name":"Filter","slug":"Filter","permalink":"https://nirajsonawane.github.io/tags/Filter/"}]},{"title":"Exchanger","slug":"Exchanger","date":"2018-06-18T12:35:57.000Z","updated":"2018-06-20T15:43:16.000Z","comments":true,"path":"2018/06/18/Exchanger/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/18/Exchanger/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial.In this article, we’ll focus on a the concept of Exchanger in the Java language. ExchangerThe exchanger class provides a kind of point for two threads, where threads can exchange their objects with other threads.An Exchanger may be viewed as a bidirectional form of a SynchronousQueue. Exchangers may be useful in applications such as genetic algorithms and pipeline designs.When a thread arrives at an exchange point, it is necessary to wait for another thread to arrive. When other partners come in threads, two threads go forward to exchange threads. In below example two threads are passing Integer values to each others. Both the Thread will wait until they receive the Information Exchanger Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class FirstThread implements Runnable &#123; private Exchanger&lt;Integer&gt; exchanger; public FirstThread(Exchanger&lt;Integer&gt; exchanger) &#123; this.exchanger = exchanger; &#125; @Override public void run() &#123; try &#123; System.out.println(\"Passing information form FirstThread\"); Integer exchange = exchanger.exchange(99); System.out.println(\"Information Sent From FirstThread\"); System.out.println(\"Received information from Second Thread.\" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class SecondThread implements Runnable &#123; private Exchanger&lt;Integer&gt; exchanger; public SecondThread(Exchanger&lt;Integer&gt; exchanger) &#123; this.exchanger = exchanger; &#125; @Override public void run() &#123; System.out.println(\"Receiving information from First Thread.\"); try &#123; Integer exchange = exchanger.exchange(2); System.out.println(\"Received information from first Thread.\" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class ExchangerExample &#123; public static void main(String[] args) &#123; Exchanger&lt;Integer&gt; exchanger = new Exchanger&lt;&gt;(); ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(2); newFixedThreadPool.submit(new FirstThread(exchanger)); newFixedThreadPool.submit(new SecondThread(exchanger)); newFixedThreadPool.shutdown(); &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"BlockingQueue","slug":"BlockingQueue","date":"2018-06-18T09:57:41.000Z","updated":"2018-06-19T01:55:18.000Z","comments":true,"path":"2018/06/18/BlockingQueue/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/18/BlockingQueue/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial.In this article, we’ll focus on a the concept of BlockingQueue in the Java language. BlockingQueueA Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element. A BlockingQueue may be capacity bounded. At any given time it may have a remainingCapacity beyond which no additional elements can be put without blocking. A BlockingQueue without any intrinsic capacity constraints always reports a remaining capacity of Integer.MAX_VALUE. BlockingQueue implementations are thread-safe. All queuing methods achieve their effects atomically using internal locks or other forms of concurrency control. However, the bulk Collection operations addAll, containsAll, retainAll and removeAll are not necessarily performed atomically unless specified otherwise in an implementation. So it is possible, for example, for addAll(c) to fail (throwing an exception) after adding only some of the elements in c. let’s implement Producer and Consumer Problem using BlockingQueue BlockingQueue Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class BlockingQueueProducer implements Runnable&#123; private BlockingQueue&lt;Integer&gt; blockingQueue; private Random random; public BlockingQueueProducer(BlockingQueue&lt;Integer&gt; blockingQueue) &#123; this.blockingQueue=blockingQueue; this.random = new Random(); &#125; @Override public void run() &#123; while(true) &#123; System.out.println(\"BlockingQueueProducer - Adding Elements\"); try &#123; blockingQueue.put(random.nextInt(3000)); System.out.println(\"Added Element : Current Size of Q \" + blockingQueue.size()); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;class BlockingQueueConsumer implements Runnable&#123; BlockingQueue&lt;Integer&gt; blockingQueue; public BlockingQueueConsumer(BlockingQueue&lt;Integer&gt; blockingQueue) &#123; this.blockingQueue=blockingQueue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; System.out.println(\"BlockingQueueConsumer : iteam recived from Q \" + blockingQueue.take() ); Thread.sleep(2500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;public class BlockingQueueExample &#123; public static void main(String[] args) &#123; BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;Integer&gt;(5); ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(2); newFixedThreadPool.submit(new BlockingQueueConsumer(blockingQueue)); newFixedThreadPool.submit(new BlockingQueueProducer(blockingQueue)); newFixedThreadPool.shutdown(); &#125;&#125; Key Pointsput(E e)Inserts the specified element into this queue, waiting if necessary for space to become available. take()Retrieves and removes the head of this queue, waiting if necessary until an element becomes available. poll()Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"CyclicBarrier","slug":"CyclicBarrier","date":"2018-06-18T04:57:26.000Z","updated":"2018-06-18T23:22:20.000Z","comments":true,"path":"2018/06/18/CyclicBarrier/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/18/CyclicBarrier/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial.In this article, we’ll focus on a the concept of CyclicBarrier in the Java language. CyclicBarrierCyclicBarrier allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released. CyclicBarrier are Similar to CountDownLatch but CyclicBarrier provide some additional features likeReseting CyclicBarrier &amp; Supports an optional Runnable command that is run once per barrier point. CyclicBarrier Example123456789101112131415161718192021222324252627282930313233343536class CyclicBarrierWorker implements Runnable&#123; private CyclicBarrier cyclicBarrier; private int workerId; private Random random; public CyclicBarrierWorker(CyclicBarrier cyclicBarrier ,int id) &#123; this.cyclicBarrier=cyclicBarrier; this.workerId=id; this.random = new Random(); &#125; @Override public void run() &#123; System.out.println(\"Starting worker ID \" + this.workerId); try &#123; Thread.sleep(random.nextInt(4000)); System.out.println(\"Worker \" + workerId + \" Completed it's work, Reducing count of cyclicBarrier \" ); cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;public class CyclicBarrierExample &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(5, ()-&gt;System.out.println(\"Barrier point reach ::: All Task Completed\")); ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(10); IntStream.range(1,6) .forEach(cnt-&gt;&#123;newFixedThreadPool.submit(new CyclicBarrierWorker(cyclicBarrier, cnt)); &#125;); System.out.println(\"All Task Submited\"); newFixedThreadPool.shutdown(); &#125; &#125;&#125; Key PointsCyclicBarrier(int parties, Runnable barrierAction) :Creates a new CyclicBarrier that will trip when the given number of parties (threads) are waiting upon it, and which will execute the given barrier action when the barrier is tripped, performed by the last thread entering the barrier. getNumberWaiting()Returns the number of parties currently waiting at the barrier. resetResets the barrier to its initial state.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"CountDownLatch","slug":"CountDownLatch","date":"2018-06-17T12:32:44.000Z","updated":"2018-06-21T19:52:38.000Z","comments":true,"path":"2018/06/17/CountDownLatch/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/17/CountDownLatch/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial.In this article, we’ll focus on a the concept of CountDownLatch in the Java language. CountDownLatchCountDownLatch enables a java thread to wait until other set of threads completes their tasks. A CountDownLatch is initialized with a given count.The await methods block until the current count reaches zero due to invocations of the countDown() method, after which all waiting threads are released and any subsequent invocations of await return immediately.This is a one-shot phenomenon – the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier. e.g. Assume we have divided one task in 5 small independent task.Now main thread should wait, till other 5 Threads finish there work.In these scenarios CountDownLatch can be used. CountDownLatch Example1234567891011121314151617181920212223242526272829303132333435class CountDownLatchWorker implements Runnable&#123; private CountDownLatch countDownLatch; private int workerId; public CountDownLatchWorker(CountDownLatch countDownLatch ,int workerId) &#123; this.countDownLatch=countDownLatch; this.workerId=workerId; &#125; @Override public void run() &#123; System.out.println(\"Worker \" + workerId + \" Started\" ); try &#123; Thread.sleep(workerId*1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Worker \" + workerId + \" Completed it's work, Reducing count of countDownLatch \" ); countDownLatch.countDown(); &#125; &#125;public class CountDownLatchExample &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(5); ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); IntStream.range(1, 6) .forEach(cnt -&gt; &#123; newCachedThreadPool.submit(new CountDownLatchWorker(countDownLatch, cnt)); &#125;); System.out.println(\"Main Thread is wating for workers to finish!!!!!!\"); countDownLatch.await(); System.out.println(\"Work of All Worker is Completed\"); newCachedThreadPool.shutdown(); &#125;&#125; Key Pointsawait MethodCauses the current thread to wait until the latch has counted down to zero, unless the thread is interrupted.If the current count is zero then this method returns immediately.If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happen: countDown MethodDecrements the count of the latch, releasing all waiting threads if the count reaches zero.If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes.If the current count equals zero then nothing happens.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Callable and Future","slug":"Callable-and-Future","date":"2018-06-17T06:57:03.000Z","updated":"2018-06-18T01:52:26.000Z","comments":true,"path":"2018/06/17/Callable-and-Future/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/17/Callable-and-Future/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial.In this quick article, we’ll focus on a the concept of Callable &amp; Future in the Java language. CallableThe Callable interface represents a thread that can return the value. It’s the same as the Runnable interface but can return the value.The callable interface can be used to Compute the value and return it to invoking thread. FutureFutureis generic interface that represents value which will be returned by callable interface.There are two methods to get actual value from Future.get() : When this method is called, thread will wait for result indefinitely.V get(long timeout, TimeUnit unit) : When this method is called, thread will wait for result only for specified time. Callable Example12345678910111213141516171819202122232425class CallableWorkerExample implements Callable&lt;String&gt;&#123; private String someReturnValue; public CallableWorkerExample(String someValue) &#123; this.someReturnValue=someValue; &#125; @Override public String call() throws Exception &#123; System.out.println(\"Working on call\"); Thread.sleep(3000); return this.someReturnValue; &#125; &#125;public class CallableAndFuture &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; CallableWorkerExample worker= new CallableWorkerExample(\"Some Value\"); ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor(); Future&lt;String&gt; submit = newSingleThreadExecutor.submit(worker); System.out.println(\"Task Submited\"); String returnValue = submit.get(); System.out.println(\"Return value from Callable \" +returnValue); &#125;&#125; Key PointsException HandlingRunnable.run method does not throws exceptions but Callable.call method throws exception.ExecutorServiceExecutorService.submit Submits a value-returning task for execution and returns a Future representing the pending results of the task.submitMethod can take Callable and Runnable task as input.But the execute Method Discussed in ExecutorServiceAndThreadPools only takes Runnable task as input.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"ExecutorServiceAndThreadPools","slug":"ExecutorServiceAndThreadPools","date":"2018-06-15T17:26:51.000Z","updated":"2018-06-16T08:34:40.000Z","comments":true,"path":"2018/06/15/ExecutorServiceAndThreadPools/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/15/ExecutorServiceAndThreadPools/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial. In this quick article, we’ll focus on a the concept of ExecutorService Framework in the Java language. ExecutorService is a framework simplifies the task of creating threads and managing thread life cycle. ExecutorService is an interface, We need its implementations in order to make any use of it. ThreadPoolExecutor &amp; ScheduledThreadPoolExecutor implementations are available in java concurrent package. Creating an ExecutorService:Executors factory methods are available for creating ExecutorService. ExecutorService executorService1 = Executors.newSingleThreadExecutor();ExecutorService executorService2 = Executors.newFixedThreadPool(10);ExecutorService executorService3 = Executors.newCachedThreadPool(); newCachedThreadPoolnewCachedThreadPool method creates an executor having an expandable thread pool.Whenever a thread is needed, pool returns a thread from cache and if not available, a new thread is created for a short time. When the timeout of thread is over, that thread is vanished. In below example 10 Threds will run Simultaneously newCachedThreadPool Example123456789101112131415161718192021222324 class MyWorker implements Runnable&#123; private int id; public MyWorker(int id) &#123; this.id=id; &#125; @Override public void run() &#123; System.out.println(\"MyWorker id \" + id + \" IS Working\" + \"Start Time \" + System.currentTimeMillis()); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;public class ExecutorServiceExample &#123; public static void main(String[] args) &#123; ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); IntStream.range(0, 10) .forEach(cnt-&gt;newCachedThreadPool.execute(new MyWorker(cnt))); newCachedThreadPool.shutdown(); &#125;&#125; newFixedThreadPoolnewFixedThreadPool method Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.. In below example 5 Threds will run Simultaneously. After Complition of task same 5 threds will be used for next 5 taks newFixedThreadPool Example123456789101112131415161718192021222324 class MyWorker implements Runnable&#123; private int id; public MyWorker(int id) &#123; this.id=id; &#125; @Override public void run() &#123; System.out.println(\"MyWorker id \" + id + \" IS Working\" + \"Start Time \" + System.currentTimeMillis()); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;public class ExecutorServiceExample &#123; public static void main(String[] args) &#123; ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(5); IntStream.range(0, 10) .forEach(cnt-&gt;newFixedThreadPool.execute(new MyWorker(cnt))); newFixedThreadPool.shutdown(); &#125;&#125; newSingleThreadExecutornewSingleThreadExecutor method Creates an Executor that uses a single worker thread operating off an unbounded queue. In below example 1 Thread will run Simultaneously. After Complition of task same threds will be used for next 10 taks newSingleThreadExecutor Example123456789101112131415161718192021222324 class MyWorker implements Runnable&#123; private int id; public MyWorker(int id) &#123; this.id=id; &#125; @Override public void run() &#123; System.out.println(\"MyWorker id \" + id + \" IS Working\" + \"Start Time \" + System.currentTimeMillis()); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;public class ExecutorServiceExample &#123; public static void main(String[] args) &#123; ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor(); IntStream.range(0, 10) .forEach(cnt-&gt;newSingleThreadExecutor.execute(new MyWorker(cnt))); newSingleThreadExecutor.shutdown(); &#125;&#125; Key Pointsshutdown()An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService.The shutdown() method will allow previously submitted tasks to execute before terminating, while the shutdownNow() method prevents waiting tasks from starting and attempts to stop currently executing tasks. execute()Executes the given command at some time in the future. The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the Executor implementation.execute method only takes runnable task.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Semaphores","slug":"Semaphores","date":"2018-06-15T12:47:27.000Z","updated":"2018-06-16T03:45:28.000Z","comments":true,"path":"2018/06/15/Semaphores/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/15/Semaphores/","excerpt":"","text":"Semaphores are a really simple concept, invented by the famous Dutch computer scientist Edsger Dijkstra. Basically a semaphore is a counter (integer) that allows a thread to get into a critical region.What the counter is counting are permits that allow access to the shared resource. Thus, to access the resource, a thread must be granted a permit from the semaphore. If the value of the counter is greater than 0 then thread get the permit otherwise waits for the permit.Once thread leaves the critical region increments the counter so that other thread can access the critical section. Most of the time we use semaphores to limit the number of concurrent threads accessing a specific resource. Examplelet consider, We want to limit connections to some resources to some max limit.Similar to connection pool.In below example 10 threads are trying to get connection at same time.But we should not allow more than 5 connections Semaphore Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.nirajsonawane;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.stream.IntStream;class ConnectionPool &#123; private Semaphore connectionSemaphore; public ConnectionPool(int poolsize) &#123; this.connectionSemaphore = new Semaphore(poolsize); &#125; public void getConnectionFromPool() &#123; if (connectionSemaphore.availablePermits() &gt; 0) &#123; connectionSemaphore.tryAcquire(); System.out.println(\"Get the connection\"); &#125; else &#123; System.out.println(\"Max active connection limit reach!! try again\"); &#125; &#125; public void releaseConnection() &#123; connectionSemaphore.release(); &#125;&#125;class ConnectionService implements Runnable &#123; private ConnectionPool connectionPool; public ConnectionService(ConnectionPool connectionPool) &#123; this.connectionPool = connectionPool; &#125; @Override public void run() &#123; connectionPool.getConnectionFromPool(); &#125;&#125;public class Semaphores &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(10); ConnectionPool connectionPool = new ConnectionPool(5); ConnectionService service = new ConnectionService(connectionPool); IntStream.range(0, 10) .forEach((cnt) -&gt; executorService.execute(service)); &#125;&#125;&#125; Out of 10 threds only 5 was able to get the connection. Key Points tryAcquire()– Return true if a permit is available immediately and acquire it otherwise return false, acquire()- Acquires a permit and blocking until one is available. release() – Release a permit availablePermits() – Return number of current permits available","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Wait-Notify-And-Notifyall","slug":"Wait-Notify-And-Notifyall","date":"2018-06-15T09:07:17.000Z","updated":"2018-06-16T01:06:58.000Z","comments":true,"path":"2018/06/15/Wait-Notify-And-Notifyall/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/15/Wait-Notify-And-Notifyall/","excerpt":"","text":"This is Sixth Article in Series of Articles on Java 8 Concurrency Tutorial. In this article, we will look at one of the most basic methods of Java-thread synchronization. Object Class in Java has three final methods to allow threads to communicate about the lock status of the threads. These methods are wait(), notify() and notifyAll().wait()Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. notify()Wakes up a single thread that is waiting on this object’s monitor. notifyAll()Wakes up all threads that are waiting on this object’s monitor. Let’s try to implement Producer &amp; Consumer problem using wait(),notify()&amp; notifyAll();Producer will add number in List. List can have maximum 5 numbers . Consumer will remove elements from list until it becomes empty. Volatile Keyword Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 package com.nirajsonawane;import java.util.ArrayList;import java.util.List;import java.util.Random;class Processor &#123; private List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); private Random random = new Random(); public synchronized void producer() &#123; while (true) &#123; try &#123; Thread.sleep(1000); if (list.size() == 5) &#123; System.out.println(\"List is full Notifying Consumer &amp; Releasing Lock\"); notifyAll(); wait(); &#125; while (list.size() &lt; 5) &#123; System.out.println(\"Adding items\"); list.add(random.nextInt()); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public synchronized void consumner() &#123; while (true) &#123; try &#123; Thread.sleep(1000); if (list.isEmpty()) &#123; System.out.println(\"List is Empty :Notifying Publisher &amp; Releasing Lock\"); notifyAll(); wait(); &#125; else &#123; System.out.println(\"Size of list \" + list.size() + \" Removed Number is \" + list.remove(0)); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125;&#125;public class WaitNotifyNotifyAllExample &#123; public static void main(String[] args) throws InterruptedException &#123; Processor p = new Processor(); Thread t1 = new Thread(() -&gt; p.producer()); Thread t2 = new Thread(() -&gt; p.consumner()); t1.start(); t2.start(); t1.join(); t2.join(); &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Volatile","slug":"Volatile","date":"2018-06-15T08:40:37.000Z","updated":"2018-06-15T22:24:46.000Z","comments":true,"path":"2018/06/15/Volatile/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/15/Volatile/","excerpt":"","text":"This is Fifth Article in Series of Articles on Java 8 Concurrency Tutorial. In this quick article, we’ll focus on a the concept of volatile keyword in the Java language. Every read of a volatile variable will be read from the RAM so from the main memory and not from cache. Usually variables are cached for performance reasons. Using volatile variables reduces the risk of memory consistency errors, because any write to a volatile variable establishes a happens-before relationship with subsequent reads of that same variable. This means that changes to a volatile variable are always visible to other thread. Volatile Keyword Example1private static volatile int COUNT = 0;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Intrinsic Locks","slug":"Intrinsic-Locks","date":"2018-06-13T02:08:33.000Z","updated":"2018-06-13T15:52:18.000Z","comments":true,"path":"2018/06/13/Intrinsic-Locks/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/13/Intrinsic-Locks/","excerpt":"","text":"This is Fourth Article in Series of Articles on Java 8 Concurrency Tutorial. Intrinsic LocksSynchronization is built around an internal entity known as the intrinsic lock or monitor lock. Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object’s state and establishing happens-before relationships that are essential to visibility. Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object’s fields has to acquire the object’s intrinsic lock before accessing them, and then release the intrinsic lock when it’s done with them. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock. Locks In Synchronized MethodsWe have discussed Synchronized Methods in previous Article Synchronization.When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method’s object and releases it when the method returns. The lock release occurs even if the return was caused by an uncaught exception. Locks In Synchronized Static MethodsAs a static method is associated with a class, not an object. In this case, the thread acquires the intrinsic lock for the Class object associated with the class. Thus access to class’s static fields is controlled by a lock that’s disti","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Synchronization","slug":"Synchronization","date":"2018-06-13T01:10:27.000Z","updated":"2018-06-13T15:33:02.000Z","comments":true,"path":"2018/06/13/Synchronization/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/13/Synchronization/","excerpt":"","text":"This is Third Article in Series of Articles on Java 8 Concurrency Tutorial. SynchronizationThreads communicate primarily by sharing access to fields and the objects reference fields refer to. This form of communication is extremely efficient, but makes two kinds of errors possible: thread interference and memory consistency errors. The tool needed to prevent these errors is synchronization. There are many situations in which multiple threads must share access to common objects.And There may be a situation when multiple threads try to access the same resource, Then they can produce inconsistent result due to concurrency issues. e.g In below example two Threads are trying to increment counter by 1000, So after end of execution. Vlaue of counter should be 2000, but that not the case. Inconsistent result due to concurrency - Without Synchronization123456789101112131415161718192021222324252627282930313233343536373839public class SynchronizedMethodExample &#123; private static int counter= 0; private static void increment() &#123; counter = counter+1; &#125; public static void main(String[] args) throws InterruptedException &#123; System.out.println(\"Main start!!\"); Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Counter \" + counter); System.out.println(\"Main End\"); &#125;&#125; If you check output , The value of Conter is not exactly equal to 2000. Synchronization idiomsThe Java programming language provides two basic synchronization idioms: synchronized methods and synchronized statements. Synchronized MethodsTo make a method synchronized, simply add the synchronized keyword to its declaration.Synchronized method is used to lock an object for any shared resource. When a thread invokes a synchronized method, it automatically acquires the lock for that object and releases it when the thread completes its task. If in above exapmle we make increment method as Synchronized, then has two effects: First, it is not possible for two invocations of synchronized methods on the same object to interleave. When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object. Second, when a synchronized method exits, it automatically establishes a happens-before relationship with any subsequent invocation of a synchronized method for the same object. This guarantees that changes to the state of the object are visible to all threads. Synchronized Method Example1234567891011121314151617181920212223242526272829303132333435363738public class SynchronizedMethodExample &#123; private static int counter= 0; private static synchronized void increment() &#123; counter = counter+1; &#125; public static void main(String[] args) throws InterruptedException &#123; System.out.println(\"Main start!!\"); Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Counter \" + counter); System.out.println(\"Main End\"); &#125;&#125; Synchronized BlocksEach time We do not have to synchronize a whole method. Sometimes it is preferable to synchronize only part of a method. Java synchronized blocks inside methods makes this possible.The increment method Can implemented by using Synchronized BlocksSynchronized Block Example1234567 private void increment()&#123; synchronized(this)&#123; counter = counter+1; &#125;&#125; It is better to use Synchronized Blocks using private object, rather than putting it on a method. Putting it on the method means you are using the lock of the object itself to provide thread safety. With this kind of mechanism, it is possible for a malicious user of your code to also obtain the lock on your object, and hold it forever, effectively blocking other threads. A non-malicious user can effectively do the same thing inadvertently. If you use the lock of a private data member, you can prevent this, since it is impossible for a malicious user to obtain the lock on your private object. Synchronized Block Example123456789 private final Object lockObject = new Object(); private void increment()&#123; synchronized(lockObject)&#123; counter = counter+1; &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Join Method","slug":"Join-Method","date":"2018-06-10T11:40:23.000Z","updated":"2018-06-11T01:41:52.000Z","comments":true,"path":"2018/06/10/Join-Method/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Join-Method/","excerpt":"","text":"This is Second Article in Series of Articles on Java 8 Concurrency Tutorial. The join method allows one thread to wait for the completion of another. If t is a Thread object whose thread is currently executing, t.join();causes the current thread to pause execution until t’s thread terminates. Overloads of join allow the programmer to specify a waiting period. However, as with sleep, join is dependent on the OS for timing, so you should not assume that join will wait exactly as long as you specify. join responds to an interrupt by exiting with an InterruptedException Join Method Example1234567891011121314public class JoinMethodExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1 = new Thread(()-&gt;System.out.println(\"Thread Number 1\")); Thread t2 = new Thread(()-&gt;System.out.println(\"Thread Number 2\")); t1.start(); t2.start(); System.out.println(\"Main Method End\"); &#125;&#125; If you check output , The main Thread ends before T2 Thread. If you want to wait for Completion of T2 then we need to call join method. Join Method Example12345678910111213141516public class JoinMethodExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1 = new Thread(()-&gt;System.out.println(\"Thread Number 1\")); Thread t2 = new Thread(()-&gt;System.out.println(\"Thread Number 2\")); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Main Method End\"); &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Creating Threads in Java","slug":"Creating-Threads","date":"2018-06-10T10:17:39.000Z","updated":"2018-06-11T01:39:22.000Z","comments":true,"path":"2018/06/10/Creating-Threads/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Creating-Threads/","excerpt":"","text":"This is First Article in Series of Articles on Java 8 Concurrency Tutorial. Threads can be Created using below ways.Extending Thread classThe First way is to extend the Thread class, and override the run()The extending class must override run() method which is the entry point of new thread. Extending Thread class1234567891011121314151617181920212223242526class ThreadRunner extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner : \" + i); &#125; &#125; &#125;public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1= new ThreadRunner(); t1.start(); System.out.println(\"Main Method End\"); &#125;&#125; Implementing the Runnable InterfaceWe Can pass an implementation of the Runnable interface to the constructor of Thread, then call start() Implementing the Runnable Interface12345678910111213141516171819202122232425class ThreadRunner implements Runnable&#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner1 : \" + i); &#125; &#125; &#125;public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1= new Thread(new ThreadRunner()); t1.start(); System.out.println(\"Main Method End\"); &#125;&#125; Threads Using Anonymous ClassesAnonymous Inner class is an inner class that is declared without any class name and that’s why it’s called anonymous. You can define an anonymous inner class within a method or even within an argument to a method. Anonymous class can be used to -Extend an class and override its method.Implement an interface and provide an implementation of its method. Threads Using Anonymous Classes1234567891011121314151617public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner : \" + i); &#125; &#125; &#125;).start(); &#125;&#125; Threads Using Java 8 LambdaRunnable is a functional interface and we can use lambda expressions to provide it’s implementation rather than using anonymous class. Threads Using Anonymous Classes12345678910public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; Runnable task = () -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner2 : \" + i); &#125; &#125;; new Thread(task).start(); &#125;&#125; Next Join Method. in Series of Articles on Java 8 Concurrency Tutorial.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Java 8 Concurrency Tutorial","slug":"Concurrency-1-0","date":"2018-06-10T09:56:34.000Z","updated":"2018-06-21T19:56:36.000Z","comments":true,"path":"2018/06/10/Concurrency-1-0/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Concurrency-1-0/","excerpt":"","text":"Welcome to Java Concurrency tutorials. These articles will describe you the Java Concurrency concepts in the context of Java 8 with easily understood code examples. The majority of concepts shown in these articles are also available in older versions of Java.However, my code samples focus on Java 8 and make heavy use of lambda expressions and other new features. Topics Creating Threads in Java Join Method Synchronization Intrinsic Locks Volatile Wait-Notify-And-Notifyall ExecutorServiceAndThreadPools Callable and Future Semaphores CountDownLatch CyclicBarrier BlockingQueue Exchanger Check The First Article in Series of Java Concurrency tutorials Creating Threads in Java.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Watching a Directory for Changes","slug":"Watching-a-Directory-for-Changes","date":"2018-06-01T01:12:32.000Z","updated":"2018-06-10T08:35:34.000Z","comments":true,"path":"2018/06/01/Watching-a-Directory-for-Changes/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/01/Watching-a-Directory-for-Changes/","excerpt":"","text":"The java.nio.file package provides a file change notification API, called the Watch Service API. This API enables you to register a directory (or directories) with the watch service. When registering, you tell the service which types of events you are interested in:1:File creation.2:File deletion.3:File Modification. When the service detects an event of interest, it is forwarded to the registered process. The registered process has a thread (or a pool of threads) dedicated to watching for any events it has registered for. When an event comes in, it is handled as needed. Creating watcher serviceThe first step is to create a new WatchService by using the newWatchService method in the FileSystem class, as follows: WatchService watcher = FileSystems.getDefault().newWatchService() Registering for EventsWe Can register one or more objects with the watch service.Any object that implements the Watchable interface can be registered.The Path class implements the Watchable interface, so each directory to be monitored is registered as a Path object. When registering an object with the watch service, you specify the types of events that you want to monitor. The supported StandardWatchEventKinds event types follow: ENTRY_CREATE – A directory entry is created. ENTRY_DELETE – A directory entry is deleted. ENTRY_MODIFY – A directory entry is modified. Registering for Events123WatchService watcher = FileSystems.getDefault().newWatchService()Path dir = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\\");dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY); Directory Watching ExamplePutting all above together. We can now go ahead and look at a complete and practical example. In below example we are going to watch directory for all the changes and will process the events. Directory Watching Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;import java.io.IOException;import java.nio.file.FileSystems;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.WatchEvent;import java.nio.file.WatchKey;import java.nio.file.WatchService; public class DirectoryChangeListeners &#123; public static void main(String[] args) throws InterruptedException &#123; try &#123; WatchService watcher = FileSystems.getDefault().newWatchService(); Path dir = Paths.get(\"C:\\\\data\\\\temp\\\\\"); dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY); System.out.println(\"Watch Service registered for dir: \" + dir.getFileName()); WatchKey key; while ((key = watcher.take())!=null) &#123; for (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123; WatchEvent.Kind&lt;?&gt; kind = event.kind(); @SuppressWarnings(\"unchecked\") WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;) event; Path fileName = ev.context(); if(kind==ENTRY_CREATE) &#123; System.out.println(\"New File Added, file Name \" + fileName); &#125; if(kind==ENTRY_DELETE) &#123; System.out.println(\"File Deleted \" + fileName); &#125; if (kind == ENTRY_MODIFY ) &#123; System.out.println(\"File Modified \" + fileName); &#125; &#125; boolean valid = key.reset(); if (!valid) &#123; break; &#125; &#125; &#125; catch (IOException ex) &#123; System.err.println(ex); &#125; &#125;&#125; Key PointsThree methods are available for Retrieving events : poll – Returns a queued key, if available. Returns immediately with a null value, if unavailable. poll(long, TimeUnit) – Returns a queued key, if one is available. If a queued key is not immediately available, the program waits until the specified time. The TimeUnit argument determines whether the specified time is nanoseconds, milliseconds, or some other unit of time. take – Returns a queued key. If no queued key is available, this method waits. Reset keyAfter the events for the key have been processed, you need to put the key back into a ready state by invoking reset. If this method returns false, the key is no longer valid and the loop can exit. This step is very important. If you fail to invoke reset, this key will not receive any further events. When to Use and Not Use This APIThe Watch Service API is designed for applications that need to be notified about file change events. It is well suited for any application, like an editor or IDE, that potentially has many open files and needs to ensure that the files are synchronized with the file system. It is also well suited for an application server that watches a directory, perhaps waiting for .jsp or .jar files to drop, in order to deploy them. This API is not designed for indexing a hard drive. Most file system implementations have native support for file change notification. The Watch Service API takes advantage of this support where available. However, when a file system does not support this mechanism, the Watch Service will poll the file system, waiting for events.","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 File Operations - Copy,Delete,Move","slug":"java-8-File-Operations-Copy-Delete-Move","date":"2018-05-30T01:22:00.000Z","updated":"2018-06-10T08:37:08.000Z","comments":true,"path":"2018/05/30/java-8-File-Operations-Copy-Delete-Move/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/30/java-8-File-Operations-Copy-Delete-Move/","excerpt":"","text":"Deleting a File or DirectoryThe Files class provides two deletion methods. 1 : The delete(Path) method deletes the file or throws an exception if the deletion fails 2 : The deleteIfExists(Path) method also deletes the file, but if the file does not exist, no exception is thrown. Delete File12345678910111213public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); try &#123; Files.delete(path); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Delete Empty Directory12345678910111213public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\\"); try &#123; Files.delete(path); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Trying to delete Non Empty Directory will throw DirectoryNotEmptyException.So, First we need to delete all files inside a particular non-empty directory: Delete Non Empty Directory1234567891011public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\\"); Files.walk(path) .sorted(Comparator.reverseOrder()) .map(Path::toFile) .forEach(File::delete); &#125; Copying a File or DirectoryYou can copy a file or directory by using thecopy(Path, Path, CopyOption...) method. The copy fails if the target file exists, unless the REPLACE_EXISTING option is specified. This method takes a varargs argument. The following StandardCopyOption and LinkOption enums are supported: REPLACE_EXISTING – replace a file if it existsCOPY_ATTRIBUTES – copy metadata to the new fileNOFOLLOW_LINKS – shouldn’t follow symbolic links Copy File12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destination.txt\"); Files.copy(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Copy Empty Directory12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destinationDir\"); Files.copy(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Copy Non empty DirectoryDirectories can be copied. However, files inside the directory are not copied, so the new directory is empty even when the original directory contains files. Copy Non Empty Directory recursively12345678910111213141516public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destinationDir\"); Files.walk(sourcepath) .forEach(source -&gt; copy(source, destinationepath.resolve(sourcepath.relativize(source)))); &#125; static void copy(Path source, Path dest) &#123; try &#123; Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; &#125; Moving a File or DirectoryYou can move a file or directory by using the move(Path, Path, CopyOption...) method.The move fails if the target file exists, unless the REPLACE_EXISTING option is specified. Empty directories can be moved. If the directory is not empty, the move is allowed when the directory can be moved without moving the contents of that directory. On UNIX systems, moving a directory within the same partition generally consists of renaming the directory. In that situation, this method works even when the directory contains files. This method takes a varargs argument – the following StandardCopyOption enums are supported: REPLACE_EXISTING – Performs the move even when the target file already exists. If the target is a symbolic link, the symbolic link is replaced but what it points to is not affected.ATOMIC_MOVE – Performs the move as an atomic file operation. If the file system does not support an atomic move, an exception is thrown. With an ATOMIC_MOVE you can move a file into a directory and be guaranteed that any process watching the directory accesses a complete file. Move File12345678public static void main(String[] args) &#123; Path sourcepath = Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\temp.txtr\");Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Move Empty Directory12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\copyme\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\copyme\"); Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Move Non Empty Directory1234567public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\copyme\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\copyme\"); Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 List all Files in Directory and Subdirectories","slug":"Java-8-List-all-Files-in-Directory-and-Subdirectories","date":"2018-05-29T02:10:02.000Z","updated":"2018-06-10T08:37:30.000Z","comments":true,"path":"2018/05/29/Java-8-List-all-Files-in-Directory-and-Subdirectories/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/29/Java-8-List-all-Files-in-Directory-and-Subdirectories/","excerpt":"","text":"List All Files in Directory and SubdirectoriesFiles.walk Return a Stream that is lazily populated with Path by walking the file tree rooted at a given starting file. Files.list Method Return a lazily populated Stream for the current directory only,Files.walk can be used to get list of files from Directory &amp; Subdirectories . Example 1: List All Files in Directory and SubdirectoriesList All Files in Directory and Subdirectories123456789101112131415public static void main(String[] args) throws IOException &#123; Path start = Paths.get(\"C:\\\\data\\\\\"); try (Stream&lt;Path&gt; stream = Files.walk(start, Integer.MAX_VALUE)) &#123; List&lt;String&gt; collect = stream .map(String::valueOf) .sorted() .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; &#125; NoteFiles.walk method takes int maxDepth as parameter. The maxDepth parameter is the maximum number of levels of directories to visit.MAX_VALUE may be used to indicate that all levels should be visited. Value 1 can be used to list files in current Directory. Example 2: List All Files in Current Directory onlyList All Files in Current Directory only12345678910111213141516public static void main(String[] args) throws IOException &#123; Path start = Paths.get(\"C:\\\\data\\\\\"); try (Stream&lt;Path&gt; stream = Files.walk(start, 1)) &#123; List&lt;String&gt; collect = stream .map(String::valueOf) .sorted() .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File With try-with-resources","slug":"Java-8-Read-File-With-try-with-resources","date":"2018-05-24T01:58:00.000Z","updated":"2018-05-24T06:46:30.000Z","comments":true,"path":"2018/05/24/Java-8-Read-File-With-try-with-resources/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/24/Java-8-Read-File-With-try-with-resources/","excerpt":"","text":"You might have noticed that In the previous post about files we have not closed any file stream. Streams implement AutoCloseable and in this case, we need to close stream explicitly. We can use try-with-resources to close the stream. Sample CodeClose BufferedReader123456789101112public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; try(BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) &#123; reader.lines().forEach(System.out::println); &#125; catch (Exception e) &#123; // TODO: handle exception &#125;&#125; Close Stream1234567891011public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; try(Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath)))) &#123; lines.forEach(System.out::println); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"5.0 -Read File With try-with-resources","slug":"Java-8/File/5-0-Read-File-With-try-with-resources","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/5-0-Read-File-With-try-with-resources/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 List All Files in Directory","slug":"java-8-List-All-Files-in-Directory","date":"2018-05-23T17:32:00.000Z","updated":"2018-05-24T08:18:22.000Z","comments":true,"path":"2018/05/23/java-8-List-All-Files-in-Directory/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/23/java-8-List-All-Files-in-Directory/","excerpt":"","text":"List All Files in DirectoryFiles.list Method Return a lazily populated Stream, the elements of which are the entries in the directory. We Can use the stream operations to find Specific Files, List file matching certain criteria, List filenames in sorted order etc. Example 1: List All Files in DirectoryList All Files in Directory12345678public static void main(String[] args) throws IOException &#123; try(Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"));) &#123; list.forEach(System.out::println); &#125; &#125; Example 2: List All Files in Directory Starting with AList All Files in Directory Starting with A1234567891011121314public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.map(path -&gt; path.getFileName() .toString()) .filter(name -&gt; name.startsWith(\"A\")) .sorted() .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 3: List Files OnlyList Files Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isFile()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 4: List Directory OnlyList Directory Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isDirectory()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 5: List Hidden files OnlyList Hidden files Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isHidden()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; NoteFiles.list Method Return a lazily populated Stream for the directory.It does not return Stream for the nested directory. For that, we Can use File.walk . Will discuss that in next chapter.","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"6.0 - List All Files in Directory","slug":"Java-8/File/6-0-List-All-Files-in-Directory","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/6-0-List-All-Files-in-Directory/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File Using Buffered Reader","slug":"Java-8-Read-File-Using-Buffered-Reader","date":"2018-05-23T01:58:08.000Z","updated":"2018-05-24T06:52:36.000Z","comments":true,"path":"2018/05/23/Java-8-Read-File-Using-Buffered-Reader/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/23/Java-8-Read-File-Using-Buffered-Reader/","excerpt":"","text":"Finally, Java 8 has made Reading &amp; Writing a text file a simple task. If we need more fine-grained control on reading we can use new Files.newBufferedReader() Read File Using Buffered Reader12345678910111213141516import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadUsingBufferedReader &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; BufferedReader reader = Files.newBufferedReader(Paths.get(filePath)); reader.lines().forEach(System.out::println); &#125; &#125; Sample.txt file1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"4.0 -Read File Using Buffered Reader","slug":"Java-8/File/4-0-Read-File-Using-Buffered-Reader","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/4-0-Read-File-Using-Buffered-Reader/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File As Single String","slug":"Java-8-Read-File-As-Single-String","date":"2018-05-22T01:58:08.000Z","updated":"2018-05-24T06:02:32.000Z","comments":true,"path":"2018/05/22/Java-8-Read-File-As-Single-String/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/22/Java-8-Read-File-As-Single-String/","excerpt":"","text":"Java 8 has added Files.lines() method, which can be used to read the file as Stream. Joining Collector Can be used to convert Stream to Single String. Read file as a stream12345678910111213141516import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadFileAsString &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath))); String fileAsString = lines.collect(Collectors.joining()); System.out.println(fileAsString); &#125; &#125; Sample.txt file for testing.1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"3.0 -Read File As Single String","slug":"Java-8/File/3-0-Read-File-As-Single-String","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/3-0-Read-File-As-Single-String/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File As A Stream","slug":"Java-8-Read-File-As-A-Stream","date":"2018-05-21T01:58:08.000Z","updated":"2018-05-24T06:03:30.000Z","comments":true,"path":"2018/05/21/Java-8-Read-File-As-A-Stream/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/21/Java-8-Read-File-As-A-Stream/","excerpt":"","text":"Java 8 has added Files.lines() method, which can be used to read the file as Stream. Read file as a stream1234567891011121314151617import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadFileAsStream &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath))); lines.forEach(System.out::println); &#125; &#125; sample.txt for testing.1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7 Output:","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"2.0 -Read File As A Stream","slug":"Java-8/File/2-0-Read-File-As-A-Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/2-0-Read-File-As-A-Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File Line By Line","slug":"Java-8-Read-File-Line-By-Line","date":"2018-05-20T01:58:08.000Z","updated":"2018-05-24T05:41:16.000Z","comments":true,"path":"2018/05/20/Java-8-Read-File-Line-By-Line/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/20/Java-8-Read-File-Line-By-Line/","excerpt":"","text":"Java 8 has addded Files.readAllLines() method ,which can be used to read file as List of Strings. Read file as a List of Strings1234567891011public class Java8ReadFileAsListOfStrings &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; List&lt;String&gt; readAllLines = Files.readAllLines(Paths.get((filePath))); readAllLines.forEach(System.out::println); &#125; &#125; Text file sample.txt for testing. 1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7 Output:","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"1.0 -Read File Line by Line","slug":"Java-8/File/1-0-Read-File-Line-by-Line","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/1-0-Read-File-Line-by-Line/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java Process Builder","slug":"Java-Process-Builder","date":"2018-05-19T18:35:48.000Z","updated":"2018-05-24T06:51:00.000Z","comments":true,"path":"2018/05/20/Java-Process-Builder/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/20/Java-Process-Builder/","excerpt":"","text":"The ProcessBuilder class is used to create separate operating system processes. There are many scenarios, Where we need to launch separate operating system processes form java program. Before JDK 5.0, We need to use the exec() method of the java.lang.Runtime class to start new process. JDK 5.0 has added ProcessBuilder to Start new OS process. Note:ProcessBuilder is not synchronized. If multiple threads access a ProcessBuilder instance concurrently, and at least one of the threads modifies one of the attributes structurally, it must be synchronized externally. Starting a new process which uses the default working directory and the environment is easy: 123Process p = new ProcessBuilder(\"myCommand\", \"myArg\").start(); The ProcessBuilder class defines two constructors, such as:12345ProcessBuilder(List&lt;String&gt; command);//Constructs a process builder with the specified operating system program and arguments.ProcessBuilder(String... command);//Constructs a process builder with the specified operating system program and arguments ProcessBuilder Examples.1:Run External bat file/sh file.In this example, We will try to run demo.bat file. The demo.bat file is at src/ root location.The out put of process builder will be printed on consol. 1234567891011121314151617181920212223242526272829303132333435public class ProcessBuilderExample &#123; public static void main(String[] args) &#123; try &#123; System.out.println(\"ProcessBuilderExample.Start!!\"); final File batchFile = new File(\"src\\\\demo.bat\"); ProcessBuilder processBuilder = new ProcessBuilder(batchFile.getAbsolutePath()); Process process = processBuilder.start(); int resposneCode = process.waitFor(); if (resposneCode == 0) &#123; System.out.println(\"Process executed successfully\"); InputStream inputStream = process.getInputStream(); String result = readInputStreamData(inputStream); System.out.println(result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static String readInputStreamData(InputStream input) throws IOException &#123; try (BufferedReader buffer = new BufferedReader(new InputStreamReader(input))) &#123; return buffer.lines() .collect(Collectors.joining(\"\\n\")); &#125; &#125;&#125; demo.bat File1echo &quot;Hello World&quot;","categories":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/categories/Java/"},{"name":"Java Process Builder","slug":"Java/Java-Process-Builder","permalink":"https://nirajsonawane.github.io/categories/Java/Java-Process-Builder/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-9","slug":"Java-9","permalink":"https://nirajsonawane.github.io/tags/Java-9/"}]}]}