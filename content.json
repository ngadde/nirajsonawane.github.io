{"meta":{"title":"Niraj Sonawane","subtitle":null,"description":null,"author":"Niraj Sonawane","url":"https://nirajsonawane.github.io"},"pages":[{"title":"About Me","date":"2018-05-19T07:47:06.000Z","updated":"2018-05-19T07:47:08.000Z","comments":true,"path":"About-Me/index.html","permalink":"https://nirajsonawane.github.io/About-Me/index.html","excerpt":"","text":""},{"title":"About Me","date":"2018-05-19T07:47:06.000Z","updated":"2018-06-15T08:07:58.000Z","comments":true,"path":"about/index.html","permalink":"https://nirajsonawane.github.io/about/index.html","excerpt":"","text":"I am a Java developer, open-source contributor, student and lifelong learner.I always love Simple design, Clean &amp; Readable Code and Unit tests. My expertise are inJava EcosystemJava8, Design Patterns, Object-Oriented Analysis and Design, Concurrency patterns, Multi threading, Parallel and Distributed Computing. Spring TechnologiesSpring Framework,Spring Boot,Spring Data,Spring Batch,Spring Rest &amp; Spring AMAQto Automation TestingCucumber,FitNesse &amp; DBfit"},{"title":"Categories","date":"2018-09-02T16:45:20.660Z","updated":"2018-06-09T13:15:44.000Z","comments":true,"path":"categories/index.html","permalink":"https://nirajsonawane.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-09-02T16:45:20.697Z","updated":"2018-06-09T13:15:44.000Z","comments":true,"path":"tags/index.html","permalink":"https://nirajsonawane.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Sort Map by Value using Custom Comparator","slug":"Sort-Map-by-Value-using-Custom-Comparator","date":"2018-09-10T08:33:33.000Z","updated":"2018-09-10T09:16:47.122Z","comments":true,"path":"2018/09/10/Sort-Map-by-Value-using-Custom-Comparator/","link":"","permalink":"https://nirajsonawane.github.io/2018/09/10/Sort-Map-by-Value-using-Custom-Comparator/","excerpt":"","text":"In this Article , we’ll Discuss How we can Sort map by Value using Comparator in java 8. Name class as key of HashMap12345public class Name &#123; private String firstName; private String lastName; //builder &#125; Name class as key of HashMap123456 public class Age &#123; private Integer year; private Integer month; //builder&#125; We want to sort Map by Age.Year. Sort map by value using Comparator123456789101112131415161718192021222324252627282930 Map&lt;Name, Age&gt; map = new HashMap&lt;&gt;();Name name0 = Name.builder().firstName(\"Zendor\").lastName(\"Sonawane\").build();Name name1 = Name.builder().firstName(\"Niraj\").lastName(\"Sonawane\").build();Name name2 = Name.builder().firstName(\"Pratik\").lastName(\"Sonawane\").build();Name name3 = Name.builder().firstName(\"Jeetesh\").lastName(\"Sonawane\").build();Name name4 = Name.builder().firstName(\"Rahul\").lastName(\"Sonawane\").build();Name name5 = Name.builder().firstName(\"Amit\").lastName(\"Sonawane\").build();Age age0 = Age.builder().year(30).month(5).build();Age age1 = Age.builder().year(66).month(3).build();Age age2 = Age.builder().year(17).month(6).build();Age age3 = Age.builder().year(3).month(5).build();Age age4 = Age.builder().year(50).month(5).build();Age age5 = Age.builder().year(80).month(12).build();map.put(name0,age0);map.put(name1,age1);map.put(name2,age2);map.put(name3,age3);map.put(name4,age4);map.put(name5,age5);Comparator&lt;Age&gt; byAge = (Age obj1,Age obj2) -&gt; obj1.getYear().compareTo(obj2.getYear());LinkedHashMap&lt;Name, Age&gt; sortedMap = map.entrySet().stream() .sorted(Map.Entry.&lt;Name,Age&gt;comparingByValue(byAge)) .collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue,(e1,e2)-&gt;e1,LinkedHashMap::new)); Source Code Github Link","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Stream","slug":"Java-8/Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Stream","slug":"Stream","permalink":"https://nirajsonawane.github.io/tags/Stream/"},{"name":"Map","slug":"Map","permalink":"https://nirajsonawane.github.io/tags/Map/"},{"name":"Sorting","slug":"Sorting","permalink":"https://nirajsonawane.github.io/tags/Sorting/"},{"name":"Comparator","slug":"Comparator","permalink":"https://nirajsonawane.github.io/tags/Comparator/"}]},{"title":"Sort Map by key using Custom Comparator","slug":"Sort-Map-by-key-using-Custom-Comparator","date":"2018-09-10T08:33:18.000Z","updated":"2018-09-10T08:46:32.180Z","comments":true,"path":"2018/09/10/Sort-Map-by-key-using-Custom-Comparator/","link":"","permalink":"https://nirajsonawane.github.io/2018/09/10/Sort-Map-by-key-using-Custom-Comparator/","excerpt":"","text":"In this Article , we’ll Discuss How we can Sort map by Custom key or Comparator in java 8. We want to sort below Map by FirstName. Name object is used as key for Map. Name class as key of HashMap12345public class Name &#123; private String firstName; private String lastName; //builder &#125; Sort map by Key using Comparator123456789101112131415 Map&lt;Name, Integer&gt; map = new HashMap&lt;&gt;();Name name0 = Name.builder().firstName(\"Zendor\").lastName(\"Sonawane\").build();Name name1 = Name.builder().firstName(\"Niraj\").lastName(\"Sonawane\").build();Name name2 = Name.builder().firstName(\"Pratik\").lastName(\"Sonawane\").build();Name name3 = Name.builder().firstName(\"Jeetesh\").lastName(\"Sonawane\").build();Name name4 = Name.builder().firstName(\"Rahul\").lastName(\"Sonawane\").build();Name name5 = Name.builder().firstName(\"Amit\").lastName(\"Sonawane\").build();map.put(name0,55);map.put(name1,1);map.put(name2,2);map.put(name3,3);map.put(name4,4);map.put(name5,5); This is how we can do that Sort map by Key using Comparator123456Comparator&lt;Name&gt; byName = (Name o1, Name o2)-&gt; o1.getFirstName().compareTo(o2.getFirstName()); LinkedHashMap&lt;Name, Integer&gt; sortedMap = map.entrySet().stream() .sorted(Map.Entry.&lt;Name,Integer&gt;comparingByKey(byName)) .collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue,(e1,e2)-&gt;e1,LinkedHashMap::new)); Source Code Github Link","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Stream","slug":"Java-8/Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Stream","slug":"Stream","permalink":"https://nirajsonawane.github.io/tags/Stream/"},{"name":"Map","slug":"Map","permalink":"https://nirajsonawane.github.io/tags/Map/"},{"name":"Sorting","slug":"Sorting","permalink":"https://nirajsonawane.github.io/tags/Sorting/"},{"name":"Comparator","slug":"Comparator","permalink":"https://nirajsonawane.github.io/tags/Comparator/"}]},{"title":"Java Stream - Sort map by value","slug":"Java-Stream-Sort-map-by-value","date":"2018-09-09T18:25:43.000Z","updated":"2018-09-10T08:26:45.267Z","comments":true,"path":"2018/09/09/Java-Stream-Sort-map-by-value/","link":"","permalink":"https://nirajsonawane.github.io/2018/09/09/Java-Stream-Sort-map-by-value/","excerpt":"","text":"In this Article , we’ll Discuss How we can Sort map by Value in java 8. We want to sort below Map by ValueSort map by Value1234567Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"Niraj\", 6); map.put(\"Rahul\", 43); map.put(\"Ram\", 44); map.put(\"Sham\", 33); map.put(\"Pratik\", 5); map.put(\"Ashok\", 5); Map Sorting using comparingByValue in Ascending orderSort map by Value Ascending order1234Map&lt;String, Integer&gt; sortedMapByValueAscending = map.entrySet().stream() .sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1,LinkedHashMap::new)); Map Sorting using comparingByValue in Descending order. For Descending order you need to use reversed()Sort map by Value Descending order1234Map&lt;String, Integer&gt; sortedMapByValueDescending = map.entrySet().stream() .sorted(Map.Entry.&lt;String,Integer&gt;comparingByValue().reversed()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1 ,LinkedHashMap::new)); Source Code Github Link","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Stream","slug":"Java-8/Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Stream","slug":"Stream","permalink":"https://nirajsonawane.github.io/tags/Stream/"},{"name":"Map","slug":"Map","permalink":"https://nirajsonawane.github.io/tags/Map/"},{"name":"Sorting","slug":"Sorting","permalink":"https://nirajsonawane.github.io/tags/Sorting/"}]},{"title":"Java Stream - Sort map by key","slug":"Java-Stream-Sort-map-by-key","date":"2018-09-09T18:25:24.000Z","updated":"2018-09-10T08:26:17.076Z","comments":true,"path":"2018/09/09/Java-Stream-Sort-map-by-key/","link":"","permalink":"https://nirajsonawane.github.io/2018/09/09/Java-Stream-Sort-map-by-key/","excerpt":"","text":"In this Article , we’ll Discuss How we can Sort map by key in java 8. We want to sort below Map by keySort map by Key1234567Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"Niraj\", 6); map.put(\"Rahul\", 43); map.put(\"Ram\", 44); map.put(\"Sham\", 33); map.put(\"Pratik\", 5); map.put(\"Ashok\", 5); Map Sorting using comparingByKey in Ascending orderSort map by Key Ascending order1234Map&lt;String, Integer&gt; sortedMapByValueAscending = map.entrySet() .stream().sorted(Map.Entry.comparingByKey()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1,LinkedHashMap::new)); Map Sorting using comparingByKey in Descending order. For Descending order you need to use reversed()Sort map by Key Descending order1234Map&lt;String, Integer&gt; sortedMapByValueDescending = map.entrySet() .stream().sorted(Map.Entry.&lt;String,Integer&gt;comparingByKey().reversed()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -&gt; e1 ,LinkedHashMap::new)); Source Code Github Link","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Stream","slug":"Java-8/Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Stream","slug":"Stream","permalink":"https://nirajsonawane.github.io/tags/Stream/"},{"name":"Map","slug":"Map","permalink":"https://nirajsonawane.github.io/tags/Map/"},{"name":"Sorting","slug":"Sorting","permalink":"https://nirajsonawane.github.io/tags/Sorting/"}]},{"title":"Java 8 Custom Collector","slug":"Java-8-Custom-Collector","date":"2018-09-03T02:52:10.000Z","updated":"2018-09-03T04:17:58.383Z","comments":true,"path":"2018/09/03/Java-8-Custom-Collector/","link":"","permalink":"https://nirajsonawane.github.io/2018/09/03/Java-8-Custom-Collector/","excerpt":"","text":"In this Article , we’ll Discuss How we can Create our own Custom Collector in java 8 and above.For this article, We will implement Summary Statistics For BigDecimal number. Java 8 Summary StatisticsJava 8 Provides Summary Statistics for Long,Int &amp; Double. These Summary classes will help you to get count, min, max, sum, and average values. LongSummaryStatistics IntSummaryStatistics DoubleSummaryStatistics IntSummaryStatistics ExampleIn below example we are trying to calculate count, min, max, sum, and average of 1 to 100 Integer. Calculate Sum,Min,Max,Count & Average12345IntSummaryStatistics summaryStatistics = IntStream.range(1, 101) .summaryStatistics(); System.out.println(summaryStatistics); implementing SummaryStatistics for Big Decimal numbersJava does not provides inbuilt Summary Statistics class for BigDecimal Number. Lets try to implement our own BigDecimal SummaryStatistics. Step 1 : Create Collector Calculate Sum,Min,Max,Count & Average123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.math.BigDecimal;import java.util.function.Consumer;import java.util.stream.Collector;public class MyBigDecimalSummaryCollector implements Consumer&lt;BigDecimal&gt; &#123; public static final int ROUND_HALF_UP = BigDecimal.ROUND_HALF_UP; public static final Integer TRANSACTIONS_SCALE = 2; private BigDecimal sum = BigDecimal.ZERO.setScale(TRANSACTIONS_SCALE, ROUND_HALF_UP); private BigDecimal minimum = BigDecimal.ZERO.setScale(TRANSACTIONS_SCALE, ROUND_HALF_UP); private BigDecimal maximum = BigDecimal.ZERO.setScale(TRANSACTIONS_SCALE, ROUND_HALF_UP); private int count; public static Collector&lt;BigDecimal, ?, MyBigDecimalSummaryCollector&gt; myBigDecimalSummaryStatistics() &#123; return Collector.of(MyBigDecimalSummaryCollector::new, MyBigDecimalSummaryCollector::accept, MyBigDecimalSummaryCollector::merge); &#125; @Override public void accept(BigDecimal t) &#123; if (count == 0) &#123; firstElementSetup(t); &#125; else &#123; sum = sum.add(t); minimum = minimum.min(t); maximum = maximum.max(t); count++; &#125; &#125; public MyBigDecimalSummaryCollector merge(MyBigDecimalSummaryCollector s) &#123; if (s.count &gt; 0) &#123; if (count == 0) &#123; setupFirstElement(s); &#125; else &#123; sum = sum.add(s.sum); minimum = minimum.min(s.minimum); maximum = maximum.max(s.maximum); count += s.count; &#125; &#125; return this; &#125; private void setupFirstElement(MyBigDecimalSummaryCollector s) &#123; count = s.count; sum = s.sum; minimum = s.minimum; maximum = s.maximum; &#125; private void firstElementSetup(BigDecimal t) &#123; count = 1; sum = t; minimum = t; maximum = t; &#125; public BigDecimal getAverage() &#123; if (count == 0) &#123; return BigDecimal.ZERO.setScale(TRANSACTIONS_SCALE, ROUND_HALF_UP); &#125; return sum.divide(BigDecimal.valueOf(count), TRANSACTIONS_SCALE, ROUND_HALF_UP); &#125; public BigDecimal getSum() &#123; return sum; &#125; public void setSum(BigDecimal sum) &#123; this.sum = sum; &#125; public BigDecimal getMinimum() &#123; return minimum; &#125; public void setMinimum(BigDecimal minimum) &#123; this.minimum = minimum; &#125; public BigDecimal getMaximum() &#123; return maximum; &#125; public void setMaximum(BigDecimal maximum) &#123; this.maximum = maximum; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; @Override public String toString() &#123; return \"MyBigDecimalSummaryCollector [sum=\" + sum + \", minimum=\" + minimum + \", maximum=\" + maximum + \", count=\" + count + \"]\"; &#125;&#125; Step 2 : Use Collector1234567MyBigDecimalSummaryCollector collect = IntStream.range(1, 101) .mapToObj(number -&gt; BigDecimal.valueOf(number)) .collect(MyBigDecimalSummaryCollector.myBigDecimalSummaryStatistics()); System.out.println(collect);","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Collector","slug":"Java-8/Collector","permalink":"https://nirajsonawane.github.io/categories/Java-8/Collector/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Java-9","slug":"Java-9","permalink":"https://nirajsonawane.github.io/tags/Java-9/"},{"name":"Collector","slug":"Collector","permalink":"https://nirajsonawane.github.io/tags/Collector/"},{"name":"Bigdecimal","slug":"Bigdecimal","permalink":"https://nirajsonawane.github.io/tags/Bigdecimal/"},{"name":"Summary Statistics","slug":"Summary-Statistics","permalink":"https://nirajsonawane.github.io/tags/Summary-Statistics/"}]},{"title":"Angular pipes","slug":"Angular-pipes","date":"2018-08-05T14:33:17.000Z","updated":"2018-09-02T16:54:28.928Z","comments":true,"path":"2018/08/05/Angular-pipes/","link":"","permalink":"https://nirajsonawane.github.io/2018/08/05/Angular-pipes/","excerpt":"","text":"Angular Pipes are used to transforms texts.A pipe takes in data as input and transforms it to a desired output LowerCase PipeTransforms text to all lower case. It is used as follows. {{value_expression | lowercase }} UpperCase PipeTransforms text to all Upper case. It is used as follows. {{ value_expression | uppercase }} TitleCasePipeTransforms text to title case. Capitalizes the first letter of each word, and transforms the rest of the word to lower case. Words are delimited by any whitespace character, such as a space, tab, or line-feed character. {{ value_expression | titlecase }} Date PipeConverts the Date to human-friendly date CurrencyPipeTransforms a number to a currency string, formatted according to locale rules that determine group sizing and separator, decimal-point character, and other locale-specific configurations.","categories":[{"name":"Angular 6","slug":"Angular-6","permalink":"https://nirajsonawane.github.io/categories/Angular-6/"}],"tags":[{"name":"Angular 6","slug":"Angular-6","permalink":"https://nirajsonawane.github.io/tags/Angular-6/"},{"name":"Pipes","slug":"Pipes","permalink":"https://nirajsonawane.github.io/tags/Pipes/"}]},{"title":"Kotlin Smart Casts","slug":"Kotlin-Smart-Casts","date":"2018-07-30T16:46:36.000Z","updated":"2018-07-31T00:29:46.000Z","comments":true,"path":"2018/07/30/Kotlin-Smart-Casts/","link":"","permalink":"https://nirajsonawane.github.io/2018/07/30/Kotlin-Smart-Casts/","excerpt":"","text":"Many times while working we need to check if an object is of certain type at runtime. In java we have instanceof operator to check whether the object is an instance of the specified type. instanceof Java Example123456public class InstanceofExample &#123; public static void main(String[] args) &#123; MyClass obj=new MyClass(); System.out.println(obj instanceof MyClass);//true &#125;&#125; In Kotlin, You can check whether an object is of a certain type at runtime by using the is operator. is operator Kotlin Example123456789if (obj is String) &#123; print(obj.length)&#125;if (obj !is String) &#123; // same as !(obj is String)print(\"Not a String\")&#125;else &#123;print(obj.length)&#125; Smart CastsKotlin Complier is quite smart and help us to avoid boilerplate code. In many cases we do not need to use explicit cast operators , because the compiler tracks the is -checks and explicit casts for immutable values and inserts (safe) casts automatically when needed: Smart Casts Kotlin Example12345fun demo(x: Any) &#123; if (x is String) &#123; print(x.length) // x is automatically cast to String &#125;&#125; The compiler is smart enough to know a cast to be safe if a negative check leads to a return:Smart Casts Kotlin Example12if (x !is String) return print(x.length) // x is automatically cast to String Such smart casts work for when-expressions and while-loops as well:Smart Casts Kotlin Example12345when (x) &#123; is Int -&gt; print(x + 1) is String -&gt; print(x.length + 1) is IntArray -&gt; print(x.sum()) &#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://nirajsonawane.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://nirajsonawane.github.io/tags/Kotlin/"},{"name":"Smart Casts","slug":"Smart-Casts","permalink":"https://nirajsonawane.github.io/tags/Smart-Casts/"},{"name":"Kotlin Types","slug":"Kotlin-Types","permalink":"https://nirajsonawane.github.io/tags/Kotlin-Types/"}]},{"title":"Remove Optional Empty/Null values from list","slug":"Remove-Optional-Empty-null-values-from-list","date":"2018-06-21T06:19:10.000Z","updated":"2018-07-30T16:39:44.000Z","comments":true,"path":"2018/06/21/Remove-Optional-Empty-null-values-from-list/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/21/Remove-Optional-Empty-null-values-from-list/","excerpt":"","text":"In this Article , we’ll Discuss, How we can Convert Stream of Optional elements to a Stream of present value elements. Java 8 has added Optional type to avoid null pointer exception. lets say we have List&lt;Optional&lt;String&gt;&gt; and for further processing we want List&lt;Strings&gt;.In This case we need to remove the null and empty elements from stream and convert it into a Stream of present value elements. Convert Stream of Optional elements to a Stream of present value elements123456789101112131415161718//Input List List&lt;Optional&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();list.add(Optional.empty());list.add(Optional.of(\"Str1\"));list.add(Optional.of(\"Str2\"));list.add(Optional.empty());list.add(Optional.ofNullable(null));//Using FilterList&lt;String&gt; listWithoutNull = list.stream() .filter(Optional::isPresent) .map(obj -&gt;obj.get()) .collect(Collectors.toList());//Using removeIf (if that list supports removal ) list.removeIf(iteam-&gt;!iteam.isPresent()); Java 9In java 9 We can easily convert Stream of optionals to a stream of present values.Using newly addded Optional::stream API java 9123List&lt;String&gt; listWithoutNull = list.stream() .flatMap(Optional::stream) .collect(Collectors.toList());","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"Stream","slug":"Java-8/Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/"},{"name":"Filter","slug":"Java-8/Stream/Filter","permalink":"https://nirajsonawane.github.io/categories/Java-8/Stream/Filter/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Java-9","slug":"Java-9","permalink":"https://nirajsonawane.github.io/tags/Java-9/"},{"name":"Optional","slug":"Optional","permalink":"https://nirajsonawane.github.io/tags/Optional/"},{"name":"Filter","slug":"Filter","permalink":"https://nirajsonawane.github.io/tags/Filter/"}]},{"title":"Exchanger","slug":"Exchanger","date":"2018-06-18T12:35:57.000Z","updated":"2018-06-20T02:13:16.000Z","comments":true,"path":"2018/06/18/Exchanger/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/18/Exchanger/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial.In this article, we’ll focus on a the concept of Exchanger in the Java language. ExchangerThe exchanger class provides a kind of point for two threads, where threads can exchange their objects with other threads.An Exchanger may be viewed as a bidirectional form of a SynchronousQueue. Exchangers may be useful in applications such as genetic algorithms and pipeline designs.When a thread arrives at an exchange point, it is necessary to wait for another thread to arrive. When other partners come in threads, two threads go forward to exchange threads. In below example two threads are passing Integer values to each others. Both the Thread will wait until they receive the Information Exchanger Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class FirstThread implements Runnable &#123; private Exchanger&lt;Integer&gt; exchanger; public FirstThread(Exchanger&lt;Integer&gt; exchanger) &#123; this.exchanger = exchanger; &#125; @Override public void run() &#123; try &#123; System.out.println(\"Passing information form FirstThread\"); Integer exchange = exchanger.exchange(99); System.out.println(\"Information Sent From FirstThread\"); System.out.println(\"Received information from Second Thread.\" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class SecondThread implements Runnable &#123; private Exchanger&lt;Integer&gt; exchanger; public SecondThread(Exchanger&lt;Integer&gt; exchanger) &#123; this.exchanger = exchanger; &#125; @Override public void run() &#123; System.out.println(\"Receiving information from First Thread.\"); try &#123; Integer exchange = exchanger.exchange(2); System.out.println(\"Received information from first Thread.\" + exchange); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class ExchangerExample &#123; public static void main(String[] args) &#123; Exchanger&lt;Integer&gt; exchanger = new Exchanger&lt;&gt;(); ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(2); newFixedThreadPool.submit(new FirstThread(exchanger)); newFixedThreadPool.submit(new SecondThread(exchanger)); newFixedThreadPool.shutdown(); &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"BlockingQueue","slug":"BlockingQueue","date":"2018-06-18T09:57:41.000Z","updated":"2018-06-18T12:25:18.000Z","comments":true,"path":"2018/06/18/BlockingQueue/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/18/BlockingQueue/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial.In this article, we’ll focus on a the concept of BlockingQueue in the Java language. BlockingQueueA Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element. A BlockingQueue may be capacity bounded. At any given time it may have a remainingCapacity beyond which no additional elements can be put without blocking. A BlockingQueue without any intrinsic capacity constraints always reports a remaining capacity of Integer.MAX_VALUE. BlockingQueue implementations are thread-safe. All queuing methods achieve their effects atomically using internal locks or other forms of concurrency control. However, the bulk Collection operations addAll, containsAll, retainAll and removeAll are not necessarily performed atomically unless specified otherwise in an implementation. So it is possible, for example, for addAll(c) to fail (throwing an exception) after adding only some of the elements in c. let’s implement Producer and Consumer Problem using BlockingQueue BlockingQueue Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class BlockingQueueProducer implements Runnable&#123; private BlockingQueue&lt;Integer&gt; blockingQueue; private Random random; public BlockingQueueProducer(BlockingQueue&lt;Integer&gt; blockingQueue) &#123; this.blockingQueue=blockingQueue; this.random = new Random(); &#125; @Override public void run() &#123; while(true) &#123; System.out.println(\"BlockingQueueProducer - Adding Elements\"); try &#123; blockingQueue.put(random.nextInt(3000)); System.out.println(\"Added Element : Current Size of Q \" + blockingQueue.size()); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;class BlockingQueueConsumer implements Runnable&#123; BlockingQueue&lt;Integer&gt; blockingQueue; public BlockingQueueConsumer(BlockingQueue&lt;Integer&gt; blockingQueue) &#123; this.blockingQueue=blockingQueue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; System.out.println(\"BlockingQueueConsumer : iteam recived from Q \" + blockingQueue.take() ); Thread.sleep(2500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;public class BlockingQueueExample &#123; public static void main(String[] args) &#123; BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;Integer&gt;(5); ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(2); newFixedThreadPool.submit(new BlockingQueueConsumer(blockingQueue)); newFixedThreadPool.submit(new BlockingQueueProducer(blockingQueue)); newFixedThreadPool.shutdown(); &#125;&#125; Key Pointsput(E e)Inserts the specified element into this queue, waiting if necessary for space to become available. take()Retrieves and removes the head of this queue, waiting if necessary until an element becomes available. poll()Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"CyclicBarrier","slug":"CyclicBarrier","date":"2018-06-18T04:57:26.000Z","updated":"2018-06-18T09:52:20.000Z","comments":true,"path":"2018/06/18/CyclicBarrier/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/18/CyclicBarrier/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial.In this article, we’ll focus on a the concept of CyclicBarrier in the Java language. CyclicBarrierCyclicBarrier allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released. CyclicBarrier are Similar to CountDownLatch but CyclicBarrier provide some additional features likeReseting CyclicBarrier &amp; Supports an optional Runnable command that is run once per barrier point. CyclicBarrier Example123456789101112131415161718192021222324252627282930313233343536class CyclicBarrierWorker implements Runnable&#123; private CyclicBarrier cyclicBarrier; private int workerId; private Random random; public CyclicBarrierWorker(CyclicBarrier cyclicBarrier ,int id) &#123; this.cyclicBarrier=cyclicBarrier; this.workerId=id; this.random = new Random(); &#125; @Override public void run() &#123; System.out.println(\"Starting worker ID \" + this.workerId); try &#123; Thread.sleep(random.nextInt(4000)); System.out.println(\"Worker \" + workerId + \" Completed it's work, Reducing count of cyclicBarrier \" ); cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125; &#125;public class CyclicBarrierExample &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(5, ()-&gt;System.out.println(\"Barrier point reach ::: All Task Completed\")); ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(10); IntStream.range(1,6) .forEach(cnt-&gt;&#123;newFixedThreadPool.submit(new CyclicBarrierWorker(cyclicBarrier, cnt)); &#125;); System.out.println(\"All Task Submited\"); newFixedThreadPool.shutdown(); &#125; &#125;&#125; Key PointsCyclicBarrier(int parties, Runnable barrierAction) :Creates a new CyclicBarrier that will trip when the given number of parties (threads) are waiting upon it, and which will execute the given barrier action when the barrier is tripped, performed by the last thread entering the barrier. getNumberWaiting()Returns the number of parties currently waiting at the barrier. resetResets the barrier to its initial state.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"CountDownLatch","slug":"CountDownLatch","date":"2018-06-17T12:32:44.000Z","updated":"2018-06-21T06:22:38.000Z","comments":true,"path":"2018/06/17/CountDownLatch/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/17/CountDownLatch/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial.In this article, we’ll focus on a the concept of CountDownLatch in the Java language. CountDownLatchCountDownLatch enables a java thread to wait until other set of threads completes their tasks. A CountDownLatch is initialized with a given count.The await methods block until the current count reaches zero due to invocations of the countDown() method, after which all waiting threads are released and any subsequent invocations of await return immediately.This is a one-shot phenomenon – the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier. e.g. Assume we have divided one task in 5 small independent task.Now main thread should wait, till other 5 Threads finish there work.In these scenarios CountDownLatch can be used. CountDownLatch Example1234567891011121314151617181920212223242526272829303132333435class CountDownLatchWorker implements Runnable&#123; private CountDownLatch countDownLatch; private int workerId; public CountDownLatchWorker(CountDownLatch countDownLatch ,int workerId) &#123; this.countDownLatch=countDownLatch; this.workerId=workerId; &#125; @Override public void run() &#123; System.out.println(\"Worker \" + workerId + \" Started\" ); try &#123; Thread.sleep(workerId*1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Worker \" + workerId + \" Completed it's work, Reducing count of countDownLatch \" ); countDownLatch.countDown(); &#125; &#125;public class CountDownLatchExample &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(5); ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); IntStream.range(1, 6) .forEach(cnt -&gt; &#123; newCachedThreadPool.submit(new CountDownLatchWorker(countDownLatch, cnt)); &#125;); System.out.println(\"Main Thread is wating for workers to finish!!!!!!\"); countDownLatch.await(); System.out.println(\"Work of All Worker is Completed\"); newCachedThreadPool.shutdown(); &#125;&#125; Key Pointsawait MethodCauses the current thread to wait until the latch has counted down to zero, unless the thread is interrupted.If the current count is zero then this method returns immediately.If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happen: countDown MethodDecrements the count of the latch, releasing all waiting threads if the count reaches zero.If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes.If the current count equals zero then nothing happens.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Callable and Future","slug":"Callable-and-Future","date":"2018-06-17T06:57:03.000Z","updated":"2018-06-17T12:22:26.000Z","comments":true,"path":"2018/06/17/Callable-and-Future/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/17/Callable-and-Future/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial.In this quick article, we’ll focus on a the concept of Callable &amp; Future in the Java language. CallableThe Callable interface represents a thread that can return the value. It’s the same as the Runnable interface but can return the value.The callable interface can be used to Compute the value and return it to invoking thread. FutureFutureis generic interface that represents value which will be returned by callable interface.There are two methods to get actual value from Future.get() : When this method is called, thread will wait for result indefinitely.V get(long timeout, TimeUnit unit) : When this method is called, thread will wait for result only for specified time. Callable Example12345678910111213141516171819202122232425class CallableWorkerExample implements Callable&lt;String&gt;&#123; private String someReturnValue; public CallableWorkerExample(String someValue) &#123; this.someReturnValue=someValue; &#125; @Override public String call() throws Exception &#123; System.out.println(\"Working on call\"); Thread.sleep(3000); return this.someReturnValue; &#125; &#125;public class CallableAndFuture &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; CallableWorkerExample worker= new CallableWorkerExample(\"Some Value\"); ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor(); Future&lt;String&gt; submit = newSingleThreadExecutor.submit(worker); System.out.println(\"Task Submited\"); String returnValue = submit.get(); System.out.println(\"Return value from Callable \" +returnValue); &#125;&#125; Key PointsException HandlingRunnable.run method does not throws exceptions but Callable.call method throws exception.ExecutorServiceExecutorService.submit Submits a value-returning task for execution and returns a Future representing the pending results of the task.submitMethod can take Callable and Runnable task as input.But the execute Method Discussed in ExecutorServiceAndThreadPools only takes Runnable task as input.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"ExecutorServiceAndThreadPools","slug":"ExecutorServiceAndThreadPools","date":"2018-06-15T17:26:51.000Z","updated":"2018-06-15T19:04:40.000Z","comments":true,"path":"2018/06/15/ExecutorServiceAndThreadPools/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/15/ExecutorServiceAndThreadPools/","excerpt":"","text":"This Article is part of Series of Articles on Java 8 Concurrency Tutorial. In this quick article, we’ll focus on a the concept of ExecutorService Framework in the Java language. ExecutorService is a framework simplifies the task of creating threads and managing thread life cycle. ExecutorService is an interface, We need its implementations in order to make any use of it. ThreadPoolExecutor &amp; ScheduledThreadPoolExecutor implementations are available in java concurrent package. Creating an ExecutorService:Executors factory methods are available for creating ExecutorService. ExecutorService executorService1 = Executors.newSingleThreadExecutor();ExecutorService executorService2 = Executors.newFixedThreadPool(10);ExecutorService executorService3 = Executors.newCachedThreadPool(); newCachedThreadPoolnewCachedThreadPool method creates an executor having an expandable thread pool.Whenever a thread is needed, pool returns a thread from cache and if not available, a new thread is created for a short time. When the timeout of thread is over, that thread is vanished. In below example 10 Threds will run Simultaneously newCachedThreadPool Example123456789101112131415161718192021222324 class MyWorker implements Runnable&#123; private int id; public MyWorker(int id) &#123; this.id=id; &#125; @Override public void run() &#123; System.out.println(\"MyWorker id \" + id + \" IS Working\" + \"Start Time \" + System.currentTimeMillis()); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;public class ExecutorServiceExample &#123; public static void main(String[] args) &#123; ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); IntStream.range(0, 10) .forEach(cnt-&gt;newCachedThreadPool.execute(new MyWorker(cnt))); newCachedThreadPool.shutdown(); &#125;&#125; newFixedThreadPoolnewFixedThreadPool method Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.. In below example 5 Threds will run Simultaneously. After Complition of task same 5 threds will be used for next 5 taks newFixedThreadPool Example123456789101112131415161718192021222324 class MyWorker implements Runnable&#123; private int id; public MyWorker(int id) &#123; this.id=id; &#125; @Override public void run() &#123; System.out.println(\"MyWorker id \" + id + \" IS Working\" + \"Start Time \" + System.currentTimeMillis()); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;public class ExecutorServiceExample &#123; public static void main(String[] args) &#123; ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(5); IntStream.range(0, 10) .forEach(cnt-&gt;newFixedThreadPool.execute(new MyWorker(cnt))); newFixedThreadPool.shutdown(); &#125;&#125; newSingleThreadExecutornewSingleThreadExecutor method Creates an Executor that uses a single worker thread operating off an unbounded queue. In below example 1 Thread will run Simultaneously. After Complition of task same threds will be used for next 10 taks newSingleThreadExecutor Example123456789101112131415161718192021222324 class MyWorker implements Runnable&#123; private int id; public MyWorker(int id) &#123; this.id=id; &#125; @Override public void run() &#123; System.out.println(\"MyWorker id \" + id + \" IS Working\" + \"Start Time \" + System.currentTimeMillis()); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;public class ExecutorServiceExample &#123; public static void main(String[] args) &#123; ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor(); IntStream.range(0, 10) .forEach(cnt-&gt;newSingleThreadExecutor.execute(new MyWorker(cnt))); newSingleThreadExecutor.shutdown(); &#125;&#125; Key Pointsshutdown()An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService.The shutdown() method will allow previously submitted tasks to execute before terminating, while the shutdownNow() method prevents waiting tasks from starting and attempts to stop currently executing tasks. execute()Executes the given command at some time in the future. The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the Executor implementation.execute method only takes runnable task.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Semaphores","slug":"Semaphores","date":"2018-06-15T12:47:27.000Z","updated":"2018-06-15T14:15:28.000Z","comments":true,"path":"2018/06/15/Semaphores/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/15/Semaphores/","excerpt":"","text":"Semaphores are a really simple concept, invented by the famous Dutch computer scientist Edsger Dijkstra. Basically a semaphore is a counter (integer) that allows a thread to get into a critical region.What the counter is counting are permits that allow access to the shared resource. Thus, to access the resource, a thread must be granted a permit from the semaphore. If the value of the counter is greater than 0 then thread get the permit otherwise waits for the permit.Once thread leaves the critical region increments the counter so that other thread can access the critical section. Most of the time we use semaphores to limit the number of concurrent threads accessing a specific resource. Examplelet consider, We want to limit connections to some resources to some max limit.Similar to connection pool.In below example 10 threads are trying to get connection at same time.But we should not allow more than 5 connections Semaphore Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.nirajsonawane;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;import java.util.stream.IntStream;class ConnectionPool &#123; private Semaphore connectionSemaphore; public ConnectionPool(int poolsize) &#123; this.connectionSemaphore = new Semaphore(poolsize); &#125; public void getConnectionFromPool() &#123; if (connectionSemaphore.availablePermits() &gt; 0) &#123; connectionSemaphore.tryAcquire(); System.out.println(\"Get the connection\"); &#125; else &#123; System.out.println(\"Max active connection limit reach!! try again\"); &#125; &#125; public void releaseConnection() &#123; connectionSemaphore.release(); &#125;&#125;class ConnectionService implements Runnable &#123; private ConnectionPool connectionPool; public ConnectionService(ConnectionPool connectionPool) &#123; this.connectionPool = connectionPool; &#125; @Override public void run() &#123; connectionPool.getConnectionFromPool(); &#125;&#125;public class Semaphores &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(10); ConnectionPool connectionPool = new ConnectionPool(5); ConnectionService service = new ConnectionService(connectionPool); IntStream.range(0, 10) .forEach((cnt) -&gt; executorService.execute(service)); &#125;&#125;&#125; Out of 10 threds only 5 was able to get the connection. Key Points tryAcquire()– Return true if a permit is available immediately and acquire it otherwise return false, acquire()- Acquires a permit and blocking until one is available. release() – Release a permit availablePermits() – Return number of current permits available","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Wait-Notify-And-Notifyall","slug":"Wait-Notify-And-Notifyall","date":"2018-06-15T09:07:17.000Z","updated":"2018-06-15T11:36:58.000Z","comments":true,"path":"2018/06/15/Wait-Notify-And-Notifyall/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/15/Wait-Notify-And-Notifyall/","excerpt":"","text":"This is Sixth Article in Series of Articles on Java 8 Concurrency Tutorial. In this article, we will look at one of the most basic methods of Java-thread synchronization. Object Class in Java has three final methods to allow threads to communicate about the lock status of the threads. These methods are wait(), notify() and notifyAll().wait()Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. notify()Wakes up a single thread that is waiting on this object’s monitor. notifyAll()Wakes up all threads that are waiting on this object’s monitor. Let’s try to implement Producer &amp; Consumer problem using wait(),notify()&amp; notifyAll();Producer will add number in List. List can have maximum 5 numbers . Consumer will remove elements from list until it becomes empty. Volatile Keyword Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 package com.nirajsonawane;import java.util.ArrayList;import java.util.List;import java.util.Random;class Processor &#123; private List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); private Random random = new Random(); public synchronized void producer() &#123; while (true) &#123; try &#123; Thread.sleep(1000); if (list.size() == 5) &#123; System.out.println(\"List is full Notifying Consumer &amp; Releasing Lock\"); notifyAll(); wait(); &#125; while (list.size() &lt; 5) &#123; System.out.println(\"Adding items\"); list.add(random.nextInt()); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public synchronized void consumner() &#123; while (true) &#123; try &#123; Thread.sleep(1000); if (list.isEmpty()) &#123; System.out.println(\"List is Empty :Notifying Publisher &amp; Releasing Lock\"); notifyAll(); wait(); &#125; else &#123; System.out.println(\"Size of list \" + list.size() + \" Removed Number is \" + list.remove(0)); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125;&#125;public class WaitNotifyNotifyAllExample &#123; public static void main(String[] args) throws InterruptedException &#123; Processor p = new Processor(); Thread t1 = new Thread(() -&gt; p.producer()); Thread t2 = new Thread(() -&gt; p.consumner()); t1.start(); t2.start(); t1.join(); t2.join(); &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Volatile","slug":"Volatile","date":"2018-06-15T08:40:37.000Z","updated":"2018-06-15T08:54:46.000Z","comments":true,"path":"2018/06/15/Volatile/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/15/Volatile/","excerpt":"","text":"This is Fifth Article in Series of Articles on Java 8 Concurrency Tutorial. In this quick article, we’ll focus on a the concept of volatile keyword in the Java language. Every read of a volatile variable will be read from the RAM so from the main memory and not from cache. Usually variables are cached for performance reasons. Using volatile variables reduces the risk of memory consistency errors, because any write to a volatile variable establishes a happens-before relationship with subsequent reads of that same variable. This means that changes to a volatile variable are always visible to other thread. Volatile Keyword Example1private static volatile int COUNT = 0;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Intrinsic Locks","slug":"Intrinsic-Locks","date":"2018-06-13T02:08:33.000Z","updated":"2018-06-13T02:22:18.000Z","comments":true,"path":"2018/06/13/Intrinsic-Locks/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/13/Intrinsic-Locks/","excerpt":"","text":"This is Fourth Article in Series of Articles on Java 8 Concurrency Tutorial. Intrinsic LocksSynchronization is built around an internal entity known as the intrinsic lock or monitor lock. Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object’s state and establishing happens-before relationships that are essential to visibility. Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object’s fields has to acquire the object’s intrinsic lock before accessing them, and then release the intrinsic lock when it’s done with them. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock. Locks In Synchronized MethodsWe have discussed Synchronized Methods in previous Article Synchronization.When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method’s object and releases it when the method returns. The lock release occurs even if the return was caused by an uncaught exception. Locks In Synchronized Static MethodsAs a static method is associated with a class, not an object. In this case, the thread acquires the intrinsic lock for the Class object associated with the class. Thus access to class’s static fields is controlled by a lock that’s disti","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Synchronization","slug":"Synchronization","date":"2018-06-13T01:10:27.000Z","updated":"2018-06-13T02:03:02.000Z","comments":true,"path":"2018/06/13/Synchronization/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/13/Synchronization/","excerpt":"","text":"This is Third Article in Series of Articles on Java 8 Concurrency Tutorial. SynchronizationThreads communicate primarily by sharing access to fields and the objects reference fields refer to. This form of communication is extremely efficient, but makes two kinds of errors possible: thread interference and memory consistency errors. The tool needed to prevent these errors is synchronization. There are many situations in which multiple threads must share access to common objects.And There may be a situation when multiple threads try to access the same resource, Then they can produce inconsistent result due to concurrency issues. e.g In below example two Threads are trying to increment counter by 1000, So after end of execution. Vlaue of counter should be 2000, but that not the case. Inconsistent result due to concurrency - Without Synchronization123456789101112131415161718192021222324252627282930313233343536373839public class SynchronizedMethodExample &#123; private static int counter= 0; private static void increment() &#123; counter = counter+1; &#125; public static void main(String[] args) throws InterruptedException &#123; System.out.println(\"Main start!!\"); Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Counter \" + counter); System.out.println(\"Main End\"); &#125;&#125; If you check output , The value of Conter is not exactly equal to 2000. Synchronization idiomsThe Java programming language provides two basic synchronization idioms: synchronized methods and synchronized statements. Synchronized MethodsTo make a method synchronized, simply add the synchronized keyword to its declaration.Synchronized method is used to lock an object for any shared resource. When a thread invokes a synchronized method, it automatically acquires the lock for that object and releases it when the thread completes its task. If in above exapmle we make increment method as Synchronized, then has two effects: First, it is not possible for two invocations of synchronized methods on the same object to interleave. When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object. Second, when a synchronized method exits, it automatically establishes a happens-before relationship with any subsequent invocation of a synchronized method for the same object. This guarantees that changes to the state of the object are visible to all threads. Synchronized Method Example1234567891011121314151617181920212223242526272829303132333435363738public class SynchronizedMethodExample &#123; private static int counter= 0; private static synchronized void increment() &#123; counter = counter+1; &#125; public static void main(String[] args) throws InterruptedException &#123; System.out.println(\"Main start!!\"); Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Counter \" + counter); System.out.println(\"Main End\"); &#125;&#125; Synchronized BlocksEach time We do not have to synchronize a whole method. Sometimes it is preferable to synchronize only part of a method. Java synchronized blocks inside methods makes this possible.The increment method Can implemented by using Synchronized BlocksSynchronized Block Example1234567 private void increment()&#123; synchronized(this)&#123; counter = counter+1; &#125;&#125; It is better to use Synchronized Blocks using private object, rather than putting it on a method. Putting it on the method means you are using the lock of the object itself to provide thread safety. With this kind of mechanism, it is possible for a malicious user of your code to also obtain the lock on your object, and hold it forever, effectively blocking other threads. A non-malicious user can effectively do the same thing inadvertently. If you use the lock of a private data member, you can prevent this, since it is impossible for a malicious user to obtain the lock on your private object. Synchronized Block Example123456789 private final Object lockObject = new Object(); private void increment()&#123; synchronized(lockObject)&#123; counter = counter+1; &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Join Method","slug":"Join-Method","date":"2018-06-10T11:40:23.000Z","updated":"2018-06-10T12:11:52.000Z","comments":true,"path":"2018/06/10/Join-Method/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Join-Method/","excerpt":"","text":"This is Second Article in Series of Articles on Java 8 Concurrency Tutorial. The join method allows one thread to wait for the completion of another. If t is a Thread object whose thread is currently executing, t.join();causes the current thread to pause execution until t’s thread terminates. Overloads of join allow the programmer to specify a waiting period. However, as with sleep, join is dependent on the OS for timing, so you should not assume that join will wait exactly as long as you specify. join responds to an interrupt by exiting with an InterruptedException Join Method Example1234567891011121314public class JoinMethodExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1 = new Thread(()-&gt;System.out.println(\"Thread Number 1\")); Thread t2 = new Thread(()-&gt;System.out.println(\"Thread Number 2\")); t1.start(); t2.start(); System.out.println(\"Main Method End\"); &#125;&#125; If you check output , The main Thread ends before T2 Thread. If you want to wait for Completion of T2 then we need to call join method. Join Method Example12345678910111213141516public class JoinMethodExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1 = new Thread(()-&gt;System.out.println(\"Thread Number 1\")); Thread t2 = new Thread(()-&gt;System.out.println(\"Thread Number 2\")); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Main Method End\"); &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Creating Threads in Java","slug":"Creating-Threads","date":"2018-06-10T10:17:39.000Z","updated":"2018-06-10T12:09:22.000Z","comments":true,"path":"2018/06/10/Creating-Threads/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Creating-Threads/","excerpt":"","text":"This is First Article in Series of Articles on Java 8 Concurrency Tutorial. Threads can be Created using below ways.Extending Thread classThe First way is to extend the Thread class, and override the run()The extending class must override run() method which is the entry point of new thread. Extending Thread class1234567891011121314151617181920212223242526class ThreadRunner extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner : \" + i); &#125; &#125; &#125;public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1= new ThreadRunner(); t1.start(); System.out.println(\"Main Method End\"); &#125;&#125; Implementing the Runnable InterfaceWe Can pass an implementation of the Runnable interface to the constructor of Thread, then call start() Implementing the Runnable Interface12345678910111213141516171819202122232425class ThreadRunner implements Runnable&#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner1 : \" + i); &#125; &#125; &#125;public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1= new Thread(new ThreadRunner()); t1.start(); System.out.println(\"Main Method End\"); &#125;&#125; Threads Using Anonymous ClassesAnonymous Inner class is an inner class that is declared without any class name and that’s why it’s called anonymous. You can define an anonymous inner class within a method or even within an argument to a method. Anonymous class can be used to -Extend an class and override its method.Implement an interface and provide an implementation of its method. Threads Using Anonymous Classes1234567891011121314151617public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner : \" + i); &#125; &#125; &#125;).start(); &#125;&#125; Threads Using Java 8 LambdaRunnable is a functional interface and we can use lambda expressions to provide it’s implementation rather than using anonymous class. Threads Using Anonymous Classes12345678910public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; Runnable task = () -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner2 : \" + i); &#125; &#125;; new Thread(task).start(); &#125;&#125; Next Join Method. in Series of Articles on Java 8 Concurrency Tutorial.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Java 8 Concurrency Tutorial","slug":"Concurrency-1-0","date":"2018-06-10T09:56:34.000Z","updated":"2018-06-21T06:26:36.000Z","comments":true,"path":"2018/06/10/Concurrency-1-0/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Concurrency-1-0/","excerpt":"","text":"Welcome to Java Concurrency tutorials. These articles will describe you the Java Concurrency concepts in the context of Java 8 with easily understood code examples. The majority of concepts shown in these articles are also available in older versions of Java.However, my code samples focus on Java 8 and make heavy use of lambda expressions and other new features. Topics Creating Threads in Java Join Method Synchronization Intrinsic Locks Volatile Wait-Notify-And-Notifyall ExecutorServiceAndThreadPools Callable and Future Semaphores CountDownLatch CyclicBarrier BlockingQueue Exchanger Check The First Article in Series of Java Concurrency tutorials Creating Threads in Java.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Watching a Directory for Changes","slug":"Watching-a-Directory-for-Changes","date":"2018-06-01T01:12:32.000Z","updated":"2018-06-09T19:05:34.000Z","comments":true,"path":"2018/06/01/Watching-a-Directory-for-Changes/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/01/Watching-a-Directory-for-Changes/","excerpt":"","text":"The java.nio.file package provides a file change notification API, called the Watch Service API. This API enables you to register a directory (or directories) with the watch service. When registering, you tell the service which types of events you are interested in:1:File creation.2:File deletion.3:File Modification. When the service detects an event of interest, it is forwarded to the registered process. The registered process has a thread (or a pool of threads) dedicated to watching for any events it has registered for. When an event comes in, it is handled as needed. Creating watcher serviceThe first step is to create a new WatchService by using the newWatchService method in the FileSystem class, as follows: WatchService watcher = FileSystems.getDefault().newWatchService() Registering for EventsWe Can register one or more objects with the watch service.Any object that implements the Watchable interface can be registered.The Path class implements the Watchable interface, so each directory to be monitored is registered as a Path object. When registering an object with the watch service, you specify the types of events that you want to monitor. The supported StandardWatchEventKinds event types follow: ENTRY_CREATE – A directory entry is created. ENTRY_DELETE – A directory entry is deleted. ENTRY_MODIFY – A directory entry is modified. Registering for Events123WatchService watcher = FileSystems.getDefault().newWatchService()Path dir = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\\");dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY); Directory Watching ExamplePutting all above together. We can now go ahead and look at a complete and practical example. In below example we are going to watch directory for all the changes and will process the events. Directory Watching Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;import java.io.IOException;import java.nio.file.FileSystems;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.WatchEvent;import java.nio.file.WatchKey;import java.nio.file.WatchService; public class DirectoryChangeListeners &#123; public static void main(String[] args) throws InterruptedException &#123; try &#123; WatchService watcher = FileSystems.getDefault().newWatchService(); Path dir = Paths.get(\"C:\\\\data\\\\temp\\\\\"); dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY); System.out.println(\"Watch Service registered for dir: \" + dir.getFileName()); WatchKey key; while ((key = watcher.take())!=null) &#123; for (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123; WatchEvent.Kind&lt;?&gt; kind = event.kind(); @SuppressWarnings(\"unchecked\") WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;) event; Path fileName = ev.context(); if(kind==ENTRY_CREATE) &#123; System.out.println(\"New File Added, file Name \" + fileName); &#125; if(kind==ENTRY_DELETE) &#123; System.out.println(\"File Deleted \" + fileName); &#125; if (kind == ENTRY_MODIFY ) &#123; System.out.println(\"File Modified \" + fileName); &#125; &#125; boolean valid = key.reset(); if (!valid) &#123; break; &#125; &#125; &#125; catch (IOException ex) &#123; System.err.println(ex); &#125; &#125;&#125; Key PointsThree methods are available for Retrieving events : poll – Returns a queued key, if available. Returns immediately with a null value, if unavailable. poll(long, TimeUnit) – Returns a queued key, if one is available. If a queued key is not immediately available, the program waits until the specified time. The TimeUnit argument determines whether the specified time is nanoseconds, milliseconds, or some other unit of time. take – Returns a queued key. If no queued key is available, this method waits. Reset keyAfter the events for the key have been processed, you need to put the key back into a ready state by invoking reset. If this method returns false, the key is no longer valid and the loop can exit. This step is very important. If you fail to invoke reset, this key will not receive any further events. When to Use and Not Use This APIThe Watch Service API is designed for applications that need to be notified about file change events. It is well suited for any application, like an editor or IDE, that potentially has many open files and needs to ensure that the files are synchronized with the file system. It is also well suited for an application server that watches a directory, perhaps waiting for .jsp or .jar files to drop, in order to deploy them. This API is not designed for indexing a hard drive. Most file system implementations have native support for file change notification. The Watch Service API takes advantage of this support where available. However, when a file system does not support this mechanism, the Watch Service will poll the file system, waiting for events.","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 File Operations - Copy,Delete,Move","slug":"java-8-File-Operations-Copy-Delete-Move","date":"2018-05-30T01:22:00.000Z","updated":"2018-06-09T19:07:08.000Z","comments":true,"path":"2018/05/30/java-8-File-Operations-Copy-Delete-Move/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/30/java-8-File-Operations-Copy-Delete-Move/","excerpt":"","text":"Deleting a File or DirectoryThe Files class provides two deletion methods. 1 : The delete(Path) method deletes the file or throws an exception if the deletion fails 2 : The deleteIfExists(Path) method also deletes the file, but if the file does not exist, no exception is thrown. Delete File12345678910111213public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); try &#123; Files.delete(path); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Delete Empty Directory12345678910111213public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\\"); try &#123; Files.delete(path); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Trying to delete Non Empty Directory will throw DirectoryNotEmptyException.So, First we need to delete all files inside a particular non-empty directory: Delete Non Empty Directory1234567891011public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\\"); Files.walk(path) .sorted(Comparator.reverseOrder()) .map(Path::toFile) .forEach(File::delete); &#125; Copying a File or DirectoryYou can copy a file or directory by using thecopy(Path, Path, CopyOption...) method. The copy fails if the target file exists, unless the REPLACE_EXISTING option is specified. This method takes a varargs argument. The following StandardCopyOption and LinkOption enums are supported: REPLACE_EXISTING – replace a file if it existsCOPY_ATTRIBUTES – copy metadata to the new fileNOFOLLOW_LINKS – shouldn’t follow symbolic links Copy File12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destination.txt\"); Files.copy(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Copy Empty Directory12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destinationDir\"); Files.copy(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Copy Non empty DirectoryDirectories can be copied. However, files inside the directory are not copied, so the new directory is empty even when the original directory contains files. Copy Non Empty Directory recursively12345678910111213141516public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destinationDir\"); Files.walk(sourcepath) .forEach(source -&gt; copy(source, destinationepath.resolve(sourcepath.relativize(source)))); &#125; static void copy(Path source, Path dest) &#123; try &#123; Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; &#125; Moving a File or DirectoryYou can move a file or directory by using the move(Path, Path, CopyOption...) method.The move fails if the target file exists, unless the REPLACE_EXISTING option is specified. Empty directories can be moved. If the directory is not empty, the move is allowed when the directory can be moved without moving the contents of that directory. On UNIX systems, moving a directory within the same partition generally consists of renaming the directory. In that situation, this method works even when the directory contains files. This method takes a varargs argument – the following StandardCopyOption enums are supported: REPLACE_EXISTING – Performs the move even when the target file already exists. If the target is a symbolic link, the symbolic link is replaced but what it points to is not affected.ATOMIC_MOVE – Performs the move as an atomic file operation. If the file system does not support an atomic move, an exception is thrown. With an ATOMIC_MOVE you can move a file into a directory and be guaranteed that any process watching the directory accesses a complete file. Move File12345678public static void main(String[] args) &#123; Path sourcepath = Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\temp.txtr\");Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Move Empty Directory12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\copyme\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\copyme\"); Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Move Non Empty Directory1234567public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\copyme\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\copyme\"); Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 List all Files in Directory and Subdirectories","slug":"Java-8-List-all-Files-in-Directory-and-Subdirectories","date":"2018-05-29T02:10:02.000Z","updated":"2018-06-09T19:07:30.000Z","comments":true,"path":"2018/05/29/Java-8-List-all-Files-in-Directory-and-Subdirectories/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/29/Java-8-List-all-Files-in-Directory-and-Subdirectories/","excerpt":"","text":"List All Files in Directory and SubdirectoriesFiles.walk Return a Stream that is lazily populated with Path by walking the file tree rooted at a given starting file. Files.list Method Return a lazily populated Stream for the current directory only,Files.walk can be used to get list of files from Directory &amp; Subdirectories . Example 1: List All Files in Directory and SubdirectoriesList All Files in Directory and Subdirectories123456789101112131415public static void main(String[] args) throws IOException &#123; Path start = Paths.get(\"C:\\\\data\\\\\"); try (Stream&lt;Path&gt; stream = Files.walk(start, Integer.MAX_VALUE)) &#123; List&lt;String&gt; collect = stream .map(String::valueOf) .sorted() .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; &#125; NoteFiles.walk method takes int maxDepth as parameter. The maxDepth parameter is the maximum number of levels of directories to visit.MAX_VALUE may be used to indicate that all levels should be visited. Value 1 can be used to list files in current Directory. Example 2: List All Files in Current Directory onlyList All Files in Current Directory only12345678910111213141516public static void main(String[] args) throws IOException &#123; Path start = Paths.get(\"C:\\\\data\\\\\"); try (Stream&lt;Path&gt; stream = Files.walk(start, 1)) &#123; List&lt;String&gt; collect = stream .map(String::valueOf) .sorted() .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File With try-with-resources","slug":"Java-8-Read-File-With-try-with-resources","date":"2018-05-24T01:58:00.000Z","updated":"2018-05-23T17:16:30.000Z","comments":true,"path":"2018/05/24/Java-8-Read-File-With-try-with-resources/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/24/Java-8-Read-File-With-try-with-resources/","excerpt":"","text":"You might have noticed that In the previous post about files we have not closed any file stream. Streams implement AutoCloseable and in this case, we need to close stream explicitly. We can use try-with-resources to close the stream. Sample CodeClose BufferedReader123456789101112public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; try(BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) &#123; reader.lines().forEach(System.out::println); &#125; catch (Exception e) &#123; // TODO: handle exception &#125;&#125; Close Stream1234567891011public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; try(Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath)))) &#123; lines.forEach(System.out::println); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"5.0 -Read File With try-with-resources","slug":"Java-8/File/5-0-Read-File-With-try-with-resources","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/5-0-Read-File-With-try-with-resources/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 List All Files in Directory","slug":"java-8-List-All-Files-in-Directory","date":"2018-05-23T17:32:00.000Z","updated":"2018-05-23T18:48:22.000Z","comments":true,"path":"2018/05/23/java-8-List-All-Files-in-Directory/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/23/java-8-List-All-Files-in-Directory/","excerpt":"","text":"List All Files in DirectoryFiles.list Method Return a lazily populated Stream, the elements of which are the entries in the directory. We Can use the stream operations to find Specific Files, List file matching certain criteria, List filenames in sorted order etc. Example 1: List All Files in DirectoryList All Files in Directory12345678public static void main(String[] args) throws IOException &#123; try(Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"));) &#123; list.forEach(System.out::println); &#125; &#125; Example 2: List All Files in Directory Starting with AList All Files in Directory Starting with A1234567891011121314public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.map(path -&gt; path.getFileName() .toString()) .filter(name -&gt; name.startsWith(\"A\")) .sorted() .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 3: List Files OnlyList Files Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isFile()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 4: List Directory OnlyList Directory Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isDirectory()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 5: List Hidden files OnlyList Hidden files Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isHidden()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; NoteFiles.list Method Return a lazily populated Stream for the directory.It does not return Stream for the nested directory. For that, we Can use File.walk . Will discuss that in next chapter.","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"6.0 - List All Files in Directory","slug":"Java-8/File/6-0-List-All-Files-in-Directory","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/6-0-List-All-Files-in-Directory/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File Using Buffered Reader","slug":"Java-8-Read-File-Using-Buffered-Reader","date":"2018-05-23T01:58:08.000Z","updated":"2018-05-23T17:22:36.000Z","comments":true,"path":"2018/05/23/Java-8-Read-File-Using-Buffered-Reader/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/23/Java-8-Read-File-Using-Buffered-Reader/","excerpt":"","text":"Finally, Java 8 has made Reading &amp; Writing a text file a simple task. If we need more fine-grained control on reading we can use new Files.newBufferedReader() Read File Using Buffered Reader12345678910111213141516import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadUsingBufferedReader &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; BufferedReader reader = Files.newBufferedReader(Paths.get(filePath)); reader.lines().forEach(System.out::println); &#125; &#125; Sample.txt file1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"4.0 -Read File Using Buffered Reader","slug":"Java-8/File/4-0-Read-File-Using-Buffered-Reader","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/4-0-Read-File-Using-Buffered-Reader/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File As Single String","slug":"Java-8-Read-File-As-Single-String","date":"2018-05-22T01:58:08.000Z","updated":"2018-05-23T16:32:32.000Z","comments":true,"path":"2018/05/22/Java-8-Read-File-As-Single-String/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/22/Java-8-Read-File-As-Single-String/","excerpt":"","text":"Java 8 has added Files.lines() method, which can be used to read the file as Stream. Joining Collector Can be used to convert Stream to Single String. Read file as a stream12345678910111213141516import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadFileAsString &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath))); String fileAsString = lines.collect(Collectors.joining()); System.out.println(fileAsString); &#125; &#125; Sample.txt file for testing.1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"3.0 -Read File As Single String","slug":"Java-8/File/3-0-Read-File-As-Single-String","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/3-0-Read-File-As-Single-String/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File As A Stream","slug":"Java-8-Read-File-As-A-Stream","date":"2018-05-21T01:58:08.000Z","updated":"2018-05-23T16:33:30.000Z","comments":true,"path":"2018/05/21/Java-8-Read-File-As-A-Stream/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/21/Java-8-Read-File-As-A-Stream/","excerpt":"","text":"Java 8 has added Files.lines() method, which can be used to read the file as Stream. Read file as a stream1234567891011121314151617import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadFileAsStream &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath))); lines.forEach(System.out::println); &#125; &#125; sample.txt for testing.1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7 Output:","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"2.0 -Read File As A Stream","slug":"Java-8/File/2-0-Read-File-As-A-Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/2-0-Read-File-As-A-Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File Line By Line","slug":"Java-8-Read-File-Line-By-Line","date":"2018-05-20T01:58:08.000Z","updated":"2018-05-23T16:11:16.000Z","comments":true,"path":"2018/05/20/Java-8-Read-File-Line-By-Line/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/20/Java-8-Read-File-Line-By-Line/","excerpt":"","text":"Java 8 has addded Files.readAllLines() method ,which can be used to read file as List of Strings. Read file as a List of Strings1234567891011public class Java8ReadFileAsListOfStrings &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; List&lt;String&gt; readAllLines = Files.readAllLines(Paths.get((filePath))); readAllLines.forEach(System.out::println); &#125; &#125; Text file sample.txt for testing. 1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7 Output:","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"1.0 -Read File Line by Line","slug":"Java-8/File/1-0-Read-File-Line-by-Line","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/1-0-Read-File-Line-by-Line/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java Process Builder","slug":"Java-Process-Builder","date":"2018-05-19T18:35:48.000Z","updated":"2018-05-23T17:21:00.000Z","comments":true,"path":"2018/05/20/Java-Process-Builder/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/20/Java-Process-Builder/","excerpt":"","text":"The ProcessBuilder class is used to create separate operating system processes. There are many scenarios, Where we need to launch separate operating system processes form java program. Before JDK 5.0, We need to use the exec() method of the java.lang.Runtime class to start new process. JDK 5.0 has added ProcessBuilder to Start new OS process. Note:ProcessBuilder is not synchronized. If multiple threads access a ProcessBuilder instance concurrently, and at least one of the threads modifies one of the attributes structurally, it must be synchronized externally. Starting a new process which uses the default working directory and the environment is easy: 123Process p = new ProcessBuilder(\"myCommand\", \"myArg\").start(); The ProcessBuilder class defines two constructors, such as:12345ProcessBuilder(List&lt;String&gt; command);//Constructs a process builder with the specified operating system program and arguments.ProcessBuilder(String... command);//Constructs a process builder with the specified operating system program and arguments ProcessBuilder Examples.1:Run External bat file/sh file.In this example, We will try to run demo.bat file. The demo.bat file is at src/ root location.The out put of process builder will be printed on consol. 1234567891011121314151617181920212223242526272829303132333435public class ProcessBuilderExample &#123; public static void main(String[] args) &#123; try &#123; System.out.println(\"ProcessBuilderExample.Start!!\"); final File batchFile = new File(\"src\\\\demo.bat\"); ProcessBuilder processBuilder = new ProcessBuilder(batchFile.getAbsolutePath()); Process process = processBuilder.start(); int resposneCode = process.waitFor(); if (resposneCode == 0) &#123; System.out.println(\"Process executed successfully\"); InputStream inputStream = process.getInputStream(); String result = readInputStreamData(inputStream); System.out.println(result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static String readInputStreamData(InputStream input) throws IOException &#123; try (BufferedReader buffer = new BufferedReader(new InputStreamReader(input))) &#123; return buffer.lines() .collect(Collectors.joining(\"\\n\")); &#125; &#125;&#125; demo.bat File1echo &quot;Hello World&quot;","categories":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/categories/Java/"},{"name":"Java Process Builder","slug":"Java/Java-Process-Builder","permalink":"https://nirajsonawane.github.io/categories/Java/Java-Process-Builder/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-9","slug":"Java-9","permalink":"https://nirajsonawane.github.io/tags/Java-9/"}]}]}