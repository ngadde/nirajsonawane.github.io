{"meta":{"title":"Niraj Sonawane","subtitle":null,"description":null,"author":"Niraj Sonawane","url":"https://nirajsonawane.github.io"},"pages":[{"title":"About Me","date":"2018-05-19T07:47:06.000Z","updated":"2018-05-19T07:47:06.355Z","comments":true,"path":"About-Me/index.html","permalink":"https://nirajsonawane.github.io/About-Me/index.html","excerpt":"","text":""},{"title":"About Me","date":"2018-05-19T07:47:06.000Z","updated":"2018-06-15T08:07:56.129Z","comments":true,"path":"about/index.html","permalink":"https://nirajsonawane.github.io/about/index.html","excerpt":"","text":"I am a Java developer, open-source contributor, student and lifelong learner.I always love Simple design, Clean &amp; Readable Code and Unit tests. My expertise are inJava EcosystemJava8, Design Patterns, Object-Oriented Analysis and Design, Concurrency patterns, Multi threading, Parallel and Distributed Computing. Spring TechnologiesSpring Framework,Spring Boot,Spring Data,Spring Batch,Spring Rest &amp; Spring AMAQto Automation TestingCucumber,FitNesse &amp; DBfit"},{"title":"Categories","date":"2018-06-09T17:17:31.485Z","updated":"2018-06-09T13:15:42.578Z","comments":true,"path":"categories/index.html","permalink":"https://nirajsonawane.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-09T17:17:31.344Z","updated":"2018-06-09T13:15:42.579Z","comments":true,"path":"tags/index.html","permalink":"https://nirajsonawane.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Wait-Notify-And-Notifyall","slug":"Wait-Notify-And-Notifyall","date":"2018-06-15T09:07:17.000Z","updated":"2018-06-15T11:36:56.779Z","comments":true,"path":"2018/06/15/Wait-Notify-And-Notifyall/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/15/Wait-Notify-And-Notifyall/","excerpt":"","text":"This is Sixth Article in Series of Articles on Java 8 Concurrency Tutorial. In this article, we will look at one of the most basic methods of Java-thread synchronization. Object Class in Java has three final methods to allow threads to communicate about the lock status of the threads. These methods are wait(), notify() and notifyAll().wait()Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. notify()Wakes up a single thread that is waiting on this object’s monitor. notifyAll()Wakes up all threads that are waiting on this object’s monitor. Let’s try to implement Producer &amp; Consumer problem using wait(),notify()&amp; notifyAll();Producer will add number in List. List can have maximum 5 numbers . Consumer will remove elements from list until it becomes empty. Volatile Keyword Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 package com.nirajsonawane;import java.util.ArrayList;import java.util.List;import java.util.Random;class Processor &#123; private List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); private Random random = new Random(); public synchronized void producer() &#123; while (true) &#123; try &#123; Thread.sleep(1000); if (list.size() == 5) &#123; System.out.println(\"List is full Notifying Consumer &amp; Releasing Lock\"); notifyAll(); wait(); &#125; while (list.size() &lt; 5) &#123; System.out.println(\"Adding items\"); list.add(random.nextInt()); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public synchronized void consumner() &#123; while (true) &#123; try &#123; Thread.sleep(1000); if (list.isEmpty()) &#123; System.out.println(\"List is Empty :Notifying Publisher &amp; Releasing Lock\"); notifyAll(); wait(); &#125; else &#123; System.out.println(\"Size of list \" + list.size() + \" Removed Number is \" + list.remove(0)); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125;&#125;public class WaitNotifyNotifyAllExample &#123; public static void main(String[] args) throws InterruptedException &#123; Processor p = new Processor(); Thread t1 = new Thread(() -&gt; p.producer()); Thread t2 = new Thread(() -&gt; p.consumner()); t1.start(); t2.start(); t1.join(); t2.join(); &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Volatile","slug":"Volatile","date":"2018-06-15T08:40:37.000Z","updated":"2018-06-15T08:54:45.606Z","comments":true,"path":"2018/06/15/Volatile/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/15/Volatile/","excerpt":"","text":"This is Fifth Article in Series of Articles on Java 8 Concurrency Tutorial. In this quick article, we’ll focus on a the concept of volatile keyword in the Java language. Every read of a volatile variable will be read from the RAM so from the main memory and not from cache. Usually variables are cached for performance reasons. Using volatile variables reduces the risk of memory consistency errors, because any write to a volatile variable establishes a happens-before relationship with subsequent reads of that same variable. This means that changes to a volatile variable are always visible to other thread. Volatile Keyword Example1private static volatile int COUNT = 0;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Intrinsic Locks","slug":"Intrinsic-Locks","date":"2018-06-13T02:08:33.000Z","updated":"2018-06-13T02:22:17.326Z","comments":true,"path":"2018/06/13/Intrinsic-Locks/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/13/Intrinsic-Locks/","excerpt":"","text":"This is Fourth Article in Series of Articles on Java 8 Concurrency Tutorial. Intrinsic LocksSynchronization is built around an internal entity known as the intrinsic lock or monitor lock. Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object’s state and establishing happens-before relationships that are essential to visibility. Every object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object’s fields has to acquire the object’s intrinsic lock before accessing them, and then release the intrinsic lock when it’s done with them. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock. Locks In Synchronized MethodsWe have discussed Synchronized Methods in previous Article Synchronization.When a thread invokes a synchronized method, it automatically acquires the intrinsic lock for that method’s object and releases it when the method returns. The lock release occurs even if the return was caused by an uncaught exception. Locks In Synchronized Static MethodsAs a static method is associated with a class, not an object. In this case, the thread acquires the intrinsic lock for the Class object associated with the class. Thus access to class’s static fields is controlled by a lock that’s disti","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Synchronization","slug":"Synchronization","date":"2018-06-13T01:10:27.000Z","updated":"2018-06-13T02:03:01.338Z","comments":true,"path":"2018/06/13/Synchronization/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/13/Synchronization/","excerpt":"","text":"This is Third Article in Series of Articles on Java 8 Concurrency Tutorial. SynchronizationThreads communicate primarily by sharing access to fields and the objects reference fields refer to. This form of communication is extremely efficient, but makes two kinds of errors possible: thread interference and memory consistency errors. The tool needed to prevent these errors is synchronization. There are many situations in which multiple threads must share access to common objects.And There may be a situation when multiple threads try to access the same resource, Then they can produce inconsistent result due to concurrency issues. e.g In below example two Threads are trying to increment counter by 1000, So after end of execution. Vlaue of counter should be 2000, but that not the case. Inconsistent result due to concurrency - Without Synchronization123456789101112131415161718192021222324252627282930313233343536373839public class SynchronizedMethodExample &#123; private static int counter= 0; private static void increment() &#123; counter = counter+1; &#125; public static void main(String[] args) throws InterruptedException &#123; System.out.println(\"Main start!!\"); Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Counter \" + counter); System.out.println(\"Main End\"); &#125;&#125; If you check output , The value of Conter is not exactly equal to 2000. Synchronization idiomsThe Java programming language provides two basic synchronization idioms: synchronized methods and synchronized statements. Synchronized MethodsTo make a method synchronized, simply add the synchronized keyword to its declaration.Synchronized method is used to lock an object for any shared resource. When a thread invokes a synchronized method, it automatically acquires the lock for that object and releases it when the thread completes its task. If in above exapmle we make increment method as Synchronized, then has two effects: First, it is not possible for two invocations of synchronized methods on the same object to interleave. When one thread is executing a synchronized method for an object, all other threads that invoke synchronized methods for the same object block (suspend execution) until the first thread is done with the object. Second, when a synchronized method exits, it automatically establishes a happens-before relationship with any subsequent invocation of a synchronized method for the same object. This guarantees that changes to the state of the object are visible to all threads. Synchronized Method Example1234567891011121314151617181920212223242526272829303132333435363738public class SynchronizedMethodExample &#123; private static int counter= 0; private static synchronized void increment() &#123; counter = counter+1; &#125; public static void main(String[] args) throws InterruptedException &#123; System.out.println(\"Main start!!\"); Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; increment(); &#125; &#125; &#125;); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Counter \" + counter); System.out.println(\"Main End\"); &#125;&#125; Synchronized BlocksEach time We do not have to synchronize a whole method. Sometimes it is preferable to synchronize only part of a method. Java synchronized blocks inside methods makes this possible.The increment method Can implemented by using Synchronized BlocksSynchronized Block Example1234567 private void increment()&#123; synchronized(this)&#123; counter = counter+1; &#125;&#125; It is better to use Synchronized Blocks using private object, rather than putting it on a method. Putting it on the method means you are using the lock of the object itself to provide thread safety. With this kind of mechanism, it is possible for a malicious user of your code to also obtain the lock on your object, and hold it forever, effectively blocking other threads. A non-malicious user can effectively do the same thing inadvertently. If you use the lock of a private data member, you can prevent this, since it is impossible for a malicious user to obtain the lock on your private object. Synchronized Block Example123456789 private final Object lockObject = new Object(); private void increment()&#123; synchronized(lockObject)&#123; counter = counter+1; &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Join Method","slug":"Join-Method","date":"2018-06-10T11:40:23.000Z","updated":"2018-06-10T12:11:51.659Z","comments":true,"path":"2018/06/10/Join-Method/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Join-Method/","excerpt":"","text":"This is Second Article in Series of Articles on Java 8 Concurrency Tutorial. The join method allows one thread to wait for the completion of another. If t is a Thread object whose thread is currently executing, t.join();causes the current thread to pause execution until t’s thread terminates. Overloads of join allow the programmer to specify a waiting period. However, as with sleep, join is dependent on the OS for timing, so you should not assume that join will wait exactly as long as you specify. join responds to an interrupt by exiting with an InterruptedException Join Method Example1234567891011121314public class JoinMethodExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1 = new Thread(()-&gt;System.out.println(\"Thread Number 1\")); Thread t2 = new Thread(()-&gt;System.out.println(\"Thread Number 2\")); t1.start(); t2.start(); System.out.println(\"Main Method End\"); &#125;&#125; If you check output , The main Thread ends before T2 Thread. If you want to wait for Completion of T2 then we need to call join method. Join Method Example12345678910111213141516public class JoinMethodExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1 = new Thread(()-&gt;System.out.println(\"Thread Number 1\")); Thread t2 = new Thread(()-&gt;System.out.println(\"Thread Number 2\")); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(\"Main Method End\"); &#125;&#125;","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Creating Threads in Java","slug":"Creating-Threads","date":"2018-06-10T10:17:39.000Z","updated":"2018-06-10T12:09:20.180Z","comments":true,"path":"2018/06/10/Creating-Threads/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Creating-Threads/","excerpt":"","text":"This is First Article in Series of Articles on Java 8 Concurrency Tutorial. Threads can be Created using below ways.Extending Thread classThe First way is to extend the Thread class, and override the run()The extending class must override run() method which is the entry point of new thread. Extending Thread class1234567891011121314151617181920212223242526class ThreadRunner extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner : \" + i); &#125; &#125; &#125;public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1= new ThreadRunner(); t1.start(); System.out.println(\"Main Method End\"); &#125;&#125; Implementing the Runnable InterfaceWe Can pass an implementation of the Runnable interface to the constructor of Thread, then call start() Implementing the Runnable Interface12345678910111213141516171819202122232425class ThreadRunner implements Runnable&#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner1 : \" + i); &#125; &#125; &#125;public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); Thread t1= new Thread(new ThreadRunner()); t1.start(); System.out.println(\"Main Method End\"); &#125;&#125; Threads Using Anonymous ClassesAnonymous Inner class is an inner class that is declared without any class name and that’s why it’s called anonymous. You can define an anonymous inner class within a method or even within an argument to a method. Anonymous class can be used to -Extend an class and override its method.Implement an interface and provide an implementation of its method. Threads Using Anonymous Classes1234567891011121314151617public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; System.out.println(\"Main Method Start\"); new Thread(new Runnable() &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner : \" + i); &#125; &#125; &#125;).start(); &#125;&#125; Threads Using Java 8 LambdaRunnable is a functional interface and we can use lambda expressions to provide it’s implementation rather than using anonymous class. Threads Using Anonymous Classes12345678910public class CreatingThreadsExample &#123; public static void main(String[] args) &#123; Runnable task = () -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"ThreadRunner2 : \" + i); &#125; &#125;; new Thread(task).start(); &#125;&#125; Next Join Method. in Series of Articles on Java 8 Concurrency Tutorial.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Java 8 Concurrency Tutorial","slug":"Concurrency-1-0","date":"2018-06-10T09:56:34.000Z","updated":"2018-06-15T11:40:08.168Z","comments":true,"path":"2018/06/10/Concurrency-1-0/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/10/Concurrency-1-0/","excerpt":"","text":"Welcome to Java Concurrency tutorials. These articles will describe you the Java Concurrency concepts in the context of Java 8 with easily understood code examples. The majority of concepts shown in these articles are also available in older versions of Java.However, my code samples focus on Java 8 and make heavy use of lambda expressions and other new features. Topics Creating Threads in Java Join Method Synchronization Intrinsic Locks Volatile Wait-Notify-And-Notifyall Threads pools with the Executor Framework Futures and Callables CompletableFuture Nonblocking algorithms Fork-Join in Java 7 Deadlock Check The First Article in Series of Java Concurrency tutorials Creating Threads in Java.","categories":[{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/categories/Multithreading/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"},{"name":"Concurrency","slug":"Concurrency","permalink":"https://nirajsonawane.github.io/tags/Concurrency/"},{"name":"Multithreading","slug":"Multithreading","permalink":"https://nirajsonawane.github.io/tags/Multithreading/"}]},{"title":"Watching a Directory for Changes","slug":"Watching-a-Directory-for-Changes","date":"2018-06-01T01:12:32.000Z","updated":"2018-06-09T19:05:32.934Z","comments":true,"path":"2018/06/01/Watching-a-Directory-for-Changes/","link":"","permalink":"https://nirajsonawane.github.io/2018/06/01/Watching-a-Directory-for-Changes/","excerpt":"","text":"The java.nio.file package provides a file change notification API, called the Watch Service API. This API enables you to register a directory (or directories) with the watch service. When registering, you tell the service which types of events you are interested in:1:File creation.2:File deletion.3:File Modification. When the service detects an event of interest, it is forwarded to the registered process. The registered process has a thread (or a pool of threads) dedicated to watching for any events it has registered for. When an event comes in, it is handled as needed. Creating watcher serviceThe first step is to create a new WatchService by using the newWatchService method in the FileSystem class, as follows: WatchService watcher = FileSystems.getDefault().newWatchService() Registering for EventsWe Can register one or more objects with the watch service.Any object that implements the Watchable interface can be registered.The Path class implements the Watchable interface, so each directory to be monitored is registered as a Path object. When registering an object with the watch service, you specify the types of events that you want to monitor. The supported StandardWatchEventKinds event types follow: ENTRY_CREATE – A directory entry is created. ENTRY_DELETE – A directory entry is deleted. ENTRY_MODIFY – A directory entry is modified. Registering for Events123WatchService watcher = FileSystems.getDefault().newWatchService()Path dir = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\\");dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY); Directory Watching ExamplePutting all above together. We can now go ahead and look at a complete and practical example. In below example we are going to watch directory for all the changes and will process the events. Directory Watching Example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;import java.io.IOException;import java.nio.file.FileSystems;import java.nio.file.Path;import java.nio.file.Paths;import java.nio.file.WatchEvent;import java.nio.file.WatchKey;import java.nio.file.WatchService; public class DirectoryChangeListeners &#123; public static void main(String[] args) throws InterruptedException &#123; try &#123; WatchService watcher = FileSystems.getDefault().newWatchService(); Path dir = Paths.get(\"C:\\\\data\\\\temp\\\\\"); dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY); System.out.println(\"Watch Service registered for dir: \" + dir.getFileName()); WatchKey key; while ((key = watcher.take())!=null) &#123; for (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123; WatchEvent.Kind&lt;?&gt; kind = event.kind(); @SuppressWarnings(\"unchecked\") WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;) event; Path fileName = ev.context(); if(kind==ENTRY_CREATE) &#123; System.out.println(\"New File Added, file Name \" + fileName); &#125; if(kind==ENTRY_DELETE) &#123; System.out.println(\"File Deleted \" + fileName); &#125; if (kind == ENTRY_MODIFY ) &#123; System.out.println(\"File Modified \" + fileName); &#125; &#125; boolean valid = key.reset(); if (!valid) &#123; break; &#125; &#125; &#125; catch (IOException ex) &#123; System.err.println(ex); &#125; &#125;&#125; Key PointsThree methods are available for Retrieving events : poll – Returns a queued key, if available. Returns immediately with a null value, if unavailable. poll(long, TimeUnit) – Returns a queued key, if one is available. If a queued key is not immediately available, the program waits until the specified time. The TimeUnit argument determines whether the specified time is nanoseconds, milliseconds, or some other unit of time. take – Returns a queued key. If no queued key is available, this method waits. Reset keyAfter the events for the key have been processed, you need to put the key back into a ready state by invoking reset. If this method returns false, the key is no longer valid and the loop can exit. This step is very important. If you fail to invoke reset, this key will not receive any further events. When to Use and Not Use This APIThe Watch Service API is designed for applications that need to be notified about file change events. It is well suited for any application, like an editor or IDE, that potentially has many open files and needs to ensure that the files are synchronized with the file system. It is also well suited for an application server that watches a directory, perhaps waiting for .jsp or .jar files to drop, in order to deploy them. This API is not designed for indexing a hard drive. Most file system implementations have native support for file change notification. The Watch Service API takes advantage of this support where available. However, when a file system does not support this mechanism, the Watch Service will poll the file system, waiting for events.","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 File Operations - Copy,Delete,Move","slug":"java-8-File-Operations-Copy-Delete-Move","date":"2018-05-30T01:22:00.000Z","updated":"2018-06-09T19:07:07.541Z","comments":true,"path":"2018/05/30/java-8-File-Operations-Copy-Delete-Move/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/30/java-8-File-Operations-Copy-Delete-Move/","excerpt":"","text":"Deleting a File or DirectoryThe Files class provides two deletion methods. 1 : The delete(Path) method deletes the file or throws an exception if the deletion fails 2 : The deleteIfExists(Path) method also deletes the file, but if the file does not exist, no exception is thrown. Delete File12345678910111213public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); try &#123; Files.delete(path); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Delete Empty Directory12345678910111213public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\\"); try &#123; Files.delete(path); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Trying to delete Non Empty Directory will throw DirectoryNotEmptyException.So, First we need to delete all files inside a particular non-empty directory: Delete Non Empty Directory1234567891011public static void main(String[] args) &#123; Path path = Paths.get(\"C:\\\\data\\\\temp\\\\\"); Files.walk(path) .sorted(Comparator.reverseOrder()) .map(Path::toFile) .forEach(File::delete); &#125; Copying a File or DirectoryYou can copy a file or directory by using thecopy(Path, Path, CopyOption...) method. The copy fails if the target file exists, unless the REPLACE_EXISTING option is specified. This method takes a varargs argument. The following StandardCopyOption and LinkOption enums are supported: REPLACE_EXISTING – replace a file if it existsCOPY_ATTRIBUTES – copy metadata to the new fileNOFOLLOW_LINKS – shouldn’t follow symbolic links Copy File12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destination.txt\"); Files.copy(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Copy Empty Directory12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destinationDir\"); Files.copy(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Copy Non empty DirectoryDirectories can be copied. However, files inside the directory are not copied, so the new directory is empty even when the original directory contains files. Copy Non Empty Directory recursively12345678910111213141516public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\destinationDir\"); Files.walk(sourcepath) .forEach(source -&gt; copy(source, destinationepath.resolve(sourcepath.relativize(source)))); &#125; static void copy(Path source, Path dest) &#123; try &#123; Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; &#125; Moving a File or DirectoryYou can move a file or directory by using the move(Path, Path, CopyOption...) method.The move fails if the target file exists, unless the REPLACE_EXISTING option is specified. Empty directories can be moved. If the directory is not empty, the move is allowed when the directory can be moved without moving the contents of that directory. On UNIX systems, moving a directory within the same partition generally consists of renaming the directory. In that situation, this method works even when the directory contains files. This method takes a varargs argument – the following StandardCopyOption enums are supported: REPLACE_EXISTING – Performs the move even when the target file already exists. If the target is a symbolic link, the symbolic link is replaced but what it points to is not affected.ATOMIC_MOVE – Performs the move as an atomic file operation. If the file system does not support an atomic move, an exception is thrown. With an ATOMIC_MOVE you can move a file into a directory and be guaranteed that any process watching the directory accesses a complete file. Move File12345678public static void main(String[] args) &#123; Path sourcepath = Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\temp.txt\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\temp.txtr\");Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Move Empty Directory12345678public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\copyme\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\copyme\"); Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125; Move Non Empty Directory1234567public static void main(String[] args) &#123; Path sourcepath = Paths.get(\"C:\\\\data\\\\temp\\\\copyme\"); Path destinationepath = Paths.get(\"C:\\\\data\\\\temp\\\\mydir\\\\copyme\"); Files.move(sourcepath, destinationepath, StandardCopyOption.REPLACE_EXISTING); &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 List all Files in Directory and Subdirectories","slug":"Java-8-List-all-Files-in-Directory-and-Subdirectories","date":"2018-05-29T02:10:02.000Z","updated":"2018-06-09T19:07:28.343Z","comments":true,"path":"2018/05/29/Java-8-List-all-Files-in-Directory-and-Subdirectories/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/29/Java-8-List-all-Files-in-Directory-and-Subdirectories/","excerpt":"","text":"List All Files in Directory and SubdirectoriesFiles.walk Return a Stream that is lazily populated with Path by walking the file tree rooted at a given starting file. Files.list Method Return a lazily populated Stream for the current directory only,Files.walk can be used to get list of files from Directory &amp; Subdirectories . Example 1: List All Files in Directory and SubdirectoriesList All Files in Directory and Subdirectories123456789101112131415public static void main(String[] args) throws IOException &#123; Path start = Paths.get(\"C:\\\\data\\\\\"); try (Stream&lt;Path&gt; stream = Files.walk(start, Integer.MAX_VALUE)) &#123; List&lt;String&gt; collect = stream .map(String::valueOf) .sorted() .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; &#125; NoteFiles.walk method takes int maxDepth as parameter. The maxDepth parameter is the maximum number of levels of directories to visit.MAX_VALUE may be used to indicate that all levels should be visited. Value 1 can be used to list files in current Directory. Example 2: List All Files in Current Directory onlyList All Files in Current Directory only12345678910111213141516public static void main(String[] args) throws IOException &#123; Path start = Paths.get(\"C:\\\\data\\\\\"); try (Stream&lt;Path&gt; stream = Files.walk(start, 1)) &#123; List&lt;String&gt; collect = stream .map(String::valueOf) .sorted() .collect(Collectors.toList()); collect.forEach(System.out::println); &#125; &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File With try-with-resources","slug":"Java-8-Read-File-With-try-with-resources","date":"2018-05-24T01:58:00.000Z","updated":"2018-05-23T17:16:29.444Z","comments":true,"path":"2018/05/24/Java-8-Read-File-With-try-with-resources/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/24/Java-8-Read-File-With-try-with-resources/","excerpt":"","text":"You might have noticed that In the previous post about files we have not closed any file stream. Streams implement AutoCloseable and in this case, we need to close stream explicitly. We can use try-with-resources to close the stream. Sample CodeClose BufferedReader123456789101112public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; try(BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) &#123; reader.lines().forEach(System.out::println); &#125; catch (Exception e) &#123; // TODO: handle exception &#125;&#125; Close Stream1234567891011public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; try(Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath)))) &#123; lines.forEach(System.out::println); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"5.0 -Read File With try-with-resources","slug":"Java-8/File/5-0-Read-File-With-try-with-resources","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/5-0-Read-File-With-try-with-resources/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 List All Files in Directory","slug":"java-8-List-All-Files-in-Directory","date":"2018-05-23T17:32:00.000Z","updated":"2018-05-23T18:48:21.282Z","comments":true,"path":"2018/05/23/java-8-List-All-Files-in-Directory/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/23/java-8-List-All-Files-in-Directory/","excerpt":"","text":"List All Files in DirectoryFiles.list Method Return a lazily populated Stream, the elements of which are the entries in the directory. We Can use the stream operations to find Specific Files, List file matching certain criteria, List filenames in sorted order etc. Example 1: List All Files in DirectoryList All Files in Directory12345678public static void main(String[] args) throws IOException &#123; try(Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"));) &#123; list.forEach(System.out::println); &#125; &#125; Example 2: List All Files in Directory Starting with AList All Files in Directory Starting with A1234567891011121314public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.map(path -&gt; path.getFileName() .toString()) .filter(name -&gt; name.startsWith(\"A\")) .sorted() .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 3: List Files OnlyList Files Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isFile()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 4: List Directory OnlyList Directory Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isDirectory()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; Example 5: List Hidden files OnlyList Hidden files Only123456789101112public static void main(String[] args) throws IOException &#123; try (Stream&lt;Path&gt; list = Files.list(Paths.get(\"C:\\\\Program Files\\\\\"))) &#123; List&lt;String&gt; fileList = list.filter(path-&gt;path.toFile().isHidden()) .map(path -&gt; path.getFileName().toString()) .collect(Collectors.toList()); fileList.forEach(System.out::println); &#125; &#125; NoteFiles.list Method Return a lazily populated Stream for the directory.It does not return Stream for the nested directory. For that, we Can use File.walk . Will discuss that in next chapter.","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"6.0 - List All Files in Directory","slug":"Java-8/File/6-0-List-All-Files-in-Directory","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/6-0-List-All-Files-in-Directory/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File Using Buffered Reader","slug":"Java-8-Read-File-Using-Buffered-Reader","date":"2018-05-23T01:58:08.000Z","updated":"2018-05-23T17:22:35.928Z","comments":true,"path":"2018/05/23/Java-8-Read-File-Using-Buffered-Reader/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/23/Java-8-Read-File-Using-Buffered-Reader/","excerpt":"","text":"Finally, Java 8 has made Reading &amp; Writing a text file a simple task. If we need more fine-grained control on reading we can use new Files.newBufferedReader() Read File Using Buffered Reader12345678910111213141516import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadUsingBufferedReader &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; BufferedReader reader = Files.newBufferedReader(Paths.get(filePath)); reader.lines().forEach(System.out::println); &#125; &#125; Sample.txt file1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"4.0 -Read File Using Buffered Reader","slug":"Java-8/File/4-0-Read-File-Using-Buffered-Reader","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/4-0-Read-File-Using-Buffered-Reader/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File As Single String","slug":"Java-8-Read-File-As-Single-String","date":"2018-05-22T01:58:08.000Z","updated":"2018-05-23T16:32:30.845Z","comments":true,"path":"2018/05/22/Java-8-Read-File-As-Single-String/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/22/Java-8-Read-File-As-Single-String/","excerpt":"","text":"Java 8 has added Files.lines() method, which can be used to read the file as Stream. Joining Collector Can be used to convert Stream to Single String. Read file as a stream12345678910111213141516import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadFileAsString &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath))); String fileAsString = lines.collect(Collectors.joining()); System.out.println(fileAsString); &#125; &#125; Sample.txt file for testing.1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"3.0 -Read File As Single String","slug":"Java-8/File/3-0-Read-File-As-Single-String","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/3-0-Read-File-As-Single-String/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File As A Stream","slug":"Java-8-Read-File-As-A-Stream","date":"2018-05-21T01:58:08.000Z","updated":"2018-05-23T16:33:28.212Z","comments":true,"path":"2018/05/21/Java-8-Read-File-As-A-Stream/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/21/Java-8-Read-File-As-A-Stream/","excerpt":"","text":"Java 8 has added Files.lines() method, which can be used to read the file as Stream. Read file as a stream1234567891011121314151617import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.stream.Stream; public class Java8ReadFileAsStream &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; Stream&lt;String&gt; lines = Files.lines(Paths.get((filePath))); lines.forEach(System.out::println); &#125; &#125; sample.txt for testing.1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7 Output:","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"2.0 -Read File As A Stream","slug":"Java-8/File/2-0-Read-File-As-A-Stream","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/2-0-Read-File-As-A-Stream/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java 8 Read File Line By Line","slug":"Java-8-Read-File-Line-By-Line","date":"2018-05-20T01:58:08.000Z","updated":"2018-05-23T16:11:15.011Z","comments":true,"path":"2018/05/20/Java-8-Read-File-Line-By-Line/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/20/Java-8-Read-File-Line-By-Line/","excerpt":"","text":"Java 8 has addded Files.readAllLines() method ,which can be used to read file as List of Strings. Read file as a List of Strings1234567891011public class Java8ReadFileAsListOfStrings &#123; public static void main(String[] args) throws IOException &#123; String filePath = \"C:\\\\data\\\\demo\\\\sample.txt\"; List&lt;String&gt; readAllLines = Files.readAllLines(Paths.get((filePath))); readAllLines.forEach(System.out::println); &#125; &#125; Text file sample.txt for testing. 1234567public final class Files extends ObjectThis class consists exclusively of static methods that operate on files, directories, or other types of files.In most cases, the methods defined here will delegate to the associated file system provider to perform the file operations.Since:1.7 Output:","categories":[{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/categories/Java-8/"},{"name":"File","slug":"Java-8/File","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/"},{"name":"1.0 -Read File Line by Line","slug":"Java-8/File/1-0-Read-File-Line-by-Line","permalink":"https://nirajsonawane.github.io/categories/Java-8/File/1-0-Read-File-Line-by-Line/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-8","slug":"Java-8","permalink":"https://nirajsonawane.github.io/tags/Java-8/"}]},{"title":"Java Process Builder","slug":"Java-Process-Builder","date":"2018-05-19T18:35:48.000Z","updated":"2018-05-23T17:20:58.527Z","comments":true,"path":"2018/05/20/Java-Process-Builder/","link":"","permalink":"https://nirajsonawane.github.io/2018/05/20/Java-Process-Builder/","excerpt":"","text":"The ProcessBuilder class is used to create separate operating system processes. There are many scenarios, Where we need to launch separate operating system processes form java program. Before JDK 5.0, We need to use the exec() method of the java.lang.Runtime class to start new process. JDK 5.0 has added ProcessBuilder to Start new OS process. Note:ProcessBuilder is not synchronized. If multiple threads access a ProcessBuilder instance concurrently, and at least one of the threads modifies one of the attributes structurally, it must be synchronized externally. Starting a new process which uses the default working directory and the environment is easy: 123Process p = new ProcessBuilder(\"myCommand\", \"myArg\").start(); The ProcessBuilder class defines two constructors, such as:12345ProcessBuilder(List&lt;String&gt; command);//Constructs a process builder with the specified operating system program and arguments.ProcessBuilder(String... command);//Constructs a process builder with the specified operating system program and arguments ProcessBuilder Examples.1:Run External bat file/sh file.In this example, We will try to run demo.bat file. The demo.bat file is at src/ root location.The out put of process builder will be printed on consol. 1234567891011121314151617181920212223242526272829303132333435public class ProcessBuilderExample &#123; public static void main(String[] args) &#123; try &#123; System.out.println(\"ProcessBuilderExample.Start!!\"); final File batchFile = new File(\"src\\\\demo.bat\"); ProcessBuilder processBuilder = new ProcessBuilder(batchFile.getAbsolutePath()); Process process = processBuilder.start(); int resposneCode = process.waitFor(); if (resposneCode == 0) &#123; System.out.println(\"Process executed successfully\"); InputStream inputStream = process.getInputStream(); String result = readInputStreamData(inputStream); System.out.println(result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static String readInputStreamData(InputStream input) throws IOException &#123; try (BufferedReader buffer = new BufferedReader(new InputStreamReader(input))) &#123; return buffer.lines() .collect(Collectors.joining(\"\\n\")); &#125; &#125;&#125; demo.bat File1echo &quot;Hello World&quot;","categories":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/categories/Java/"},{"name":"Java Process Builder","slug":"Java/Java-Process-Builder","permalink":"https://nirajsonawane.github.io/categories/Java/Java-Process-Builder/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://nirajsonawane.github.io/tags/Java/"},{"name":"Java-9","slug":"Java-9","permalink":"https://nirajsonawane.github.io/tags/Java-9/"}]}]}